{"version":3,"sources":["../../../src/lib/metadata/get-metadata-route.ts"],"sourcesContent":["import { isMetadataRoute } from './is-metadata-route'\nimport path from '../../shared/lib/isomorphic/path'\nimport { interpolateDynamicPath } from '../../server/server-utils'\nimport { getNamedRouteRegex } from '../../shared/lib/router/utils/route-regex'\nimport { djb2Hash } from '../../shared/lib/hash'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep'\n\n/*\n * If there's special convention like (...) or @ in the page path,\n * Give it a unique hash suffix to avoid conflicts\n *\n * e.g.\n * /app/opengraph-image.tsx -> /opengraph-image\n * /app/(post)/opengraph-image.tsx -> /opengraph-image-[0-9a-z]{6}\n */\nfunction getMetadataRouteSuffix(page: string) {\n  let suffix = ''\n\n  if ((page.includes('(') && page.includes(')')) || page.includes('@')) {\n    suffix = djb2Hash(page).toString(36).slice(0, 6)\n  }\n  return suffix\n}\n\n/**\n * Fill the dynamic segment in the metadata route\n *\n * Example:\n * fillMetadataSegment('/a/[slug]', { params: { slug: 'b' } }, 'open-graph') -> '/a/b/open-graph'\n *\n */\nexport function fillMetadataSegment(\n  segment: string,\n  params: any,\n  imageSegment: string\n) {\n  const pathname = normalizeAppPath(segment)\n  const routeRegex = getNamedRouteRegex(pathname, false)\n  const route = interpolateDynamicPath(pathname, params, routeRegex)\n  const suffix = getMetadataRouteSuffix(segment)\n  const routeSuffix = suffix ? `-${suffix}` : ''\n\n  const { name, ext } = path.parse(imageSegment)\n\n  return normalizePathSep(path.join(route, `${name}${routeSuffix}${ext}`))\n}\n\n/**\n * Map metadata page key to the corresponding route\n *\n * static file page key:    /app/robots.txt -> /robots.xml -> /robots.txt/route\n * dynamic route page key:  /app/robots.tsx -> /robots -> /robots.txt/route\n *\n * @param page\n * @returns\n */\nexport function normalizeMetadataRoute(page: string) {\n  if (!isMetadataRoute(page)) {\n    return page\n  }\n  let route = page\n  let suffix = ''\n  if (page === '/robots') {\n    route += '.txt'\n  } else if (page === '/manifest') {\n    route += '.webmanifest'\n  } else {\n    // Remove the file extension,\n    // e.g. /path/robots.txt -> /route-path\n    // e.g. /path/opengraph-image.tsx -> /path/opengraph-image\n    const pathnamePrefix = page.slice(0, -(path.basename(page).length + 1))\n    suffix = getMetadataRouteSuffix(pathnamePrefix)\n  }\n  // Support both /<metadata-route.ext> and custom routes /<metadata-route>/route.ts.\n  // If it's a metadata file route, we need to append /[id]/route to the page.\n  if (!route.endsWith('/route')) {\n    const { dir, name: baseName, ext } = path.parse(route)\n    route = path.posix.join(\n      dir,\n      `${baseName}${suffix ? `-${suffix}` : ''}${ext}`,\n      'route'\n    )\n  }\n\n  return route\n}\n\n// Normalize metadata route page to either a single route or a dynamic route.\n// e.g. Input: /sitemap/route\n// when isDynamic is false, single route -> /sitemap.xml/route\n// when isDynamic is false, dynamic route -> /sitemap/[__metadata_id__]/route\n// also works for pathname such as /sitemap -> /sitemap.xml, but will not append /route suffix\nexport function normalizeMetadataPageToRoute(page: string, isDynamic: boolean) {\n  const isRoute = page.endsWith('/route')\n  const routePagePath = isRoute ? page.slice(0, -'/route'.length) : page\n  const metadataRouteExtension = routePagePath.endsWith('/sitemap')\n    ? '.xml'\n    : ''\n  const mapped = isDynamic\n    ? `${routePagePath}/[__metadata_id__]`\n    : `${routePagePath}${metadataRouteExtension}`\n\n  return mapped + (isRoute ? '/route' : '')\n}\n"],"names":["fillMetadataSegment","normalizeMetadataPageToRoute","normalizeMetadataRoute","getMetadataRouteSuffix","page","suffix","includes","djb2Hash","toString","slice","segment","params","imageSegment","pathname","normalizeAppPath","routeRegex","getNamedRouteRegex","route","interpolateDynamicPath","routeSuffix","name","ext","path","parse","normalizePathSep","join","isMetadataRoute","pathnamePrefix","basename","length","endsWith","dir","baseName","posix","isDynamic","isRoute","routePagePath","metadataRouteExtension","mapped"],"mappings":";;;;;;;;;;;;;;;;IAgCgBA,mBAAmB;eAAnBA;;IA6DAC,4BAA4B;eAA5BA;;IApCAC,sBAAsB;eAAtBA;;;iCAzDgB;6DACf;6BACsB;4BACJ;sBACV;0BACQ;kCACA;;;;;;AAEjC;;;;;;;CAOC,GACD,SAASC,uBAAuBC,IAAY;IAC1C,IAAIC,SAAS;IAEb,IAAI,AAACD,KAAKE,QAAQ,CAAC,QAAQF,KAAKE,QAAQ,CAAC,QAASF,KAAKE,QAAQ,CAAC,MAAM;QACpED,SAASE,IAAAA,cAAQ,EAACH,MAAMI,QAAQ,CAAC,IAAIC,KAAK,CAAC,GAAG;IAChD;IACA,OAAOJ;AACT;AASO,SAASL,oBACdU,OAAe,EACfC,MAAW,EACXC,YAAoB;IAEpB,MAAMC,WAAWC,IAAAA,0BAAgB,EAACJ;IAClC,MAAMK,aAAaC,IAAAA,8BAAkB,EAACH,UAAU;IAChD,MAAMI,QAAQC,IAAAA,mCAAsB,EAACL,UAAUF,QAAQI;IACvD,MAAMV,SAASF,uBAAuBO;IACtC,MAAMS,cAAcd,SAAS,CAAC,CAAC,EAAEA,OAAO,CAAC,GAAG;IAE5C,MAAM,EAAEe,IAAI,EAAEC,GAAG,EAAE,GAAGC,aAAI,CAACC,KAAK,CAACX;IAEjC,OAAOY,IAAAA,kCAAgB,EAACF,aAAI,CAACG,IAAI,CAACR,OAAO,CAAC,EAAEG,KAAK,EAAED,YAAY,EAAEE,IAAI,CAAC;AACxE;AAWO,SAASnB,uBAAuBE,IAAY;IACjD,IAAI,CAACsB,IAAAA,gCAAe,EAACtB,OAAO;QAC1B,OAAOA;IACT;IACA,IAAIa,QAAQb;IACZ,IAAIC,SAAS;IACb,IAAID,SAAS,WAAW;QACtBa,SAAS;IACX,OAAO,IAAIb,SAAS,aAAa;QAC/Ba,SAAS;IACX,OAAO;QACL,6BAA6B;QAC7B,uCAAuC;QACvC,0DAA0D;QAC1D,MAAMU,iBAAiBvB,KAAKK,KAAK,CAAC,GAAG,CAAEa,CAAAA,aAAI,CAACM,QAAQ,CAACxB,MAAMyB,MAAM,GAAG,CAAA;QACpExB,SAASF,uBAAuBwB;IAClC;IACA,mFAAmF;IACnF,4EAA4E;IAC5E,IAAI,CAACV,MAAMa,QAAQ,CAAC,WAAW;QAC7B,MAAM,EAAEC,GAAG,EAAEX,MAAMY,QAAQ,EAAEX,GAAG,EAAE,GAAGC,aAAI,CAACC,KAAK,CAACN;QAChDA,QAAQK,aAAI,CAACW,KAAK,CAACR,IAAI,CACrBM,KACA,CAAC,EAAEC,SAAS,EAAE3B,SAAS,CAAC,CAAC,EAAEA,OAAO,CAAC,GAAG,GAAG,EAAEgB,IAAI,CAAC,EAChD;IAEJ;IAEA,OAAOJ;AACT;AAOO,SAAShB,6BAA6BG,IAAY,EAAE8B,SAAkB;IAC3E,MAAMC,UAAU/B,KAAK0B,QAAQ,CAAC;IAC9B,MAAMM,gBAAgBD,UAAU/B,KAAKK,KAAK,CAAC,GAAG,CAAC,SAASoB,MAAM,IAAIzB;IAClE,MAAMiC,yBAAyBD,cAAcN,QAAQ,CAAC,cAClD,SACA;IACJ,MAAMQ,SAASJ,YACX,CAAC,EAAEE,cAAc,kBAAkB,CAAC,GACpC,CAAC,EAAEA,cAAc,EAAEC,uBAAuB,CAAC;IAE/C,OAAOC,SAAUH,CAAAA,UAAU,WAAW,EAAC;AACzC"}