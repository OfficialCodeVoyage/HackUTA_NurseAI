{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type {\n  AppRenderContext,\n  GetDynamicParamFromSegment,\n} from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport {\n  createDefaultMetadata,\n  createDefaultViewport,\n} from './default-metadata'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport type { MetadataContext } from './types/resolvers'\n\nexport function createMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts']\n): MetadataContext {\n  return {\n    pathname,\n    trailingSlash: renderOpts.trailingSlash,\n    isStandaloneMode: renderOpts.nextConfigOutput === 'standalone',\n  }\n}\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  query,\n  metadataContext,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n}: {\n  tree: LoaderTree\n  query: ParsedUrlQuery\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, React.ComponentType] {\n  let resolve: (value: Error | undefined) => void | undefined\n  // Only use promise.resolve here to avoid unhandled rejections\n  const metadataErrorResolving = new Promise<Error | undefined>((res) => {\n    resolve = res\n  })\n\n  async function MetadataTree() {\n    const defaultMetadata = createDefaultMetadata()\n    const defaultViewport = createDefaultViewport()\n    let metadata: ResolvedMetadata | undefined = defaultMetadata\n    let viewport: ResolvedViewport | undefined = defaultViewport\n    let error: any\n    const errorMetadataItem: [null, null, null] = [null, null, null]\n    const errorConvention = errorType === 'redirect' ? undefined : errorType\n    const searchParams = createDynamicallyTrackedSearchParams(query)\n\n    const [resolvedError, resolvedMetadata, resolvedViewport] =\n      await resolveMetadata({\n        tree,\n        parentParams: {},\n        metadataItems: [],\n        errorMetadataItem,\n        searchParams,\n        getDynamicParamFromSegment,\n        errorConvention,\n        metadataContext,\n      })\n    if (!resolvedError) {\n      viewport = resolvedViewport\n      metadata = resolvedMetadata\n      resolve(undefined)\n    } else {\n      error = resolvedError\n      // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n      // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n      // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n      // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n      if (!errorType && isNotFoundError(resolvedError)) {\n        const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n          await resolveMetadata({\n            tree,\n            parentParams: {},\n            metadataItems: [],\n            errorMetadataItem,\n            searchParams,\n            getDynamicParamFromSegment,\n            errorConvention: 'not-found',\n            metadataContext,\n          })\n        viewport = notFoundViewport\n        metadata = notFoundMetadata\n        error = notFoundMetadataError || error\n      }\n      resolve(error)\n    }\n\n    const elements = MetaFilter([\n      ViewportMeta({ viewport: viewport }),\n      BasicMeta({ metadata }),\n      AlternatesMetadata({ alternates: metadata.alternates }),\n      ItunesMeta({ itunes: metadata.itunes }),\n      FacebookMeta({ facebook: metadata.facebook }),\n      FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n      VerificationMeta({ verification: metadata.verification }),\n      AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n      OpenGraphMetadata({ openGraph: metadata.openGraph }),\n      TwitterMetadata({ twitter: metadata.twitter }),\n      AppLinksMeta({ appLinks: metadata.appLinks }),\n      IconsMetadata({ icons: metadata.icons }),\n    ])\n\n    if (appUsingSizeAdjustment) elements.push(<meta name=\"next-size-adjust\" />)\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n      </>\n    )\n  }\n\n  async function MetadataOutlet() {\n    const error = await metadataErrorResolving\n    if (error) {\n      throw error\n    }\n    return null\n  }\n\n  return [MetadataTree, MetadataOutlet]\n}\n"],"names":["createMetadataComponents","createMetadataContext","pathname","renderOpts","trailingSlash","isStandaloneMode","nextConfigOutput","tree","query","metadataContext","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","resolve","metadataErrorResolving","Promise","res","MetadataTree","defaultMetadata","createDefaultMetadata","defaultViewport","createDefaultViewport","metadata","viewport","error","errorMetadataItem","errorConvention","undefined","searchParams","resolvedError","resolvedMetadata","resolvedViewport","resolveMetadata","parentParams","metadataItems","isNotFoundError","notFoundMetadataError","notFoundMetadata","notFoundViewport","elements","MetaFilter","ViewportMeta","BasicMeta","AlternatesMetadata","alternates","ItunesMeta","itunes","FacebookMeta","facebook","FormatDetectionMeta","formatDetection","VerificationMeta","verification","AppleWebAppMeta","appleWebApp","OpenGraphMetadata","openGraph","TwitterMetadata","twitter","AppLinksMeta","appLinks","IconsMetadata","icons","push","meta","name","map","el","index","React","cloneElement","key","MetadataOutlet"],"mappings":"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"}