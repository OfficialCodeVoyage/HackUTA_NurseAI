{"version":3,"sources":["../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState,\n  flightSegmentPath: FlightSegmentPath\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key],\n          flightSegmentPath\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(\n      flightRouterState,\n      treePatch,\n      flightSegmentPath\n    )\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      flightSegmentPath\n    )\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      flightSegmentPath.slice(2),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["applyRouterStatePatchToTree","applyPatch","initialTree","patchTree","flightSegmentPath","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","DEFAULT_SEGMENT_KEY","matchSegment","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","addRefreshMarkerToActiveParallelSegments","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch","slice"],"mappings":";;;;+BA8EgBA;;;eAAAA;;;yBA1EoB;+BACP;iDAC4B;AAEzD;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B,EAC5BC,iBAAoC;IAEpC,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGJ;IAChD,MAAM,CAACK,cAAcC,oBAAoB,GAAGL;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEI,iBAAiBE,4BAAmB,IACpCJ,mBAAmBI,4BAAmB,EACtC;QACA,OAAOP;IACT;IAEA,IAAIQ,IAAAA,2BAAY,EAACL,gBAAgBE,eAAe;QAC9C,MAAMI,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAON,sBAAuB;YACvC,MAAMO,8BACJ,OAAOL,mBAAmB,CAACI,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGX,WACvBK,qBAAqB,CAACM,IAAI,EAC1BJ,mBAAmB,CAACI,IAAI,EACxBR;YAEJ,OAAO;gBACLO,iBAAiB,CAACC,IAAI,GAAGN,qBAAqB,CAACM,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOJ,oBAAqB;YACrC,IAAIG,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGJ,mBAAmB,CAACI,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACT;YAAgBM;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIT,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOY;IACT;IAEA,OAAOX;AACT;AAOO,SAASH,4BACdI,iBAAoC,EACpCW,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAIX,kBAAkBmB,MAAM,KAAK,GAAG;QAClC,MAAMT,OAA0Bb,WAC9Bc,mBACAC,WACAZ;QAGFoB,IAAAA,yEAAwC,EAACV,MAAMG;QAE/C,OAAOH;IACT;IAEA,MAAM,CAACW,gBAAgBC,iBAAiB,GAAGtB;IAE3C,iGAAiG;IACjG,IAAI,CAACM,IAAAA,2BAAY,EAACe,gBAAgBP,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMS,cAAcvB,kBAAkBmB,MAAM,KAAK;IAEjD,IAAIK;IACJ,IAAID,aAAa;QACfC,qBAAqB3B,WACnBkB,cAAc,CAACO,iBAAiB,EAChCV,WACAZ;IAEJ,OAAO;QACLwB,qBAAqB5B,4BACnBI,kBAAkByB,KAAK,CAAC,IACxBV,cAAc,CAACO,iBAAiB,EAChCV,WACAC;QAGF,IAAIW,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMd,OAA0B;QAC9BV,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGe,cAAc;YACjB,CAACO,iBAAiB,EAAEE;QACtB;QACAR;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBR,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAU,IAAAA,yEAAwC,EAACV,MAAMG;IAE/C,OAAOH;AACT"}