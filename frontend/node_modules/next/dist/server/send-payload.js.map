{"version":3,"sources":["../../src/server/send-payload.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type RenderResult from './render-result'\nimport type { Revalidate, SwrDelta } from './lib/revalidate'\n\nimport { isResSent } from '../shared/lib/utils'\nimport { generateETag } from './lib/etag'\nimport fresh from 'next/dist/compiled/fresh'\nimport { formatRevalidate } from './lib/revalidate'\nimport { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'\n\nexport function sendEtagResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  etag: string | undefined\n): boolean {\n  if (etag) {\n    /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */\n    res.setHeader('ETag', etag)\n  }\n\n  if (fresh(req.headers, { etag })) {\n    res.statusCode = 304\n    res.end()\n    return true\n  }\n\n  return false\n}\n\nexport async function sendRenderResult({\n  req,\n  res,\n  result,\n  type,\n  generateEtags,\n  poweredByHeader,\n  revalidate,\n  swrDelta,\n}: {\n  req: IncomingMessage\n  res: ServerResponse\n  result: RenderResult\n  type: 'html' | 'json' | 'rsc'\n  generateEtags: boolean\n  poweredByHeader: boolean\n  revalidate: Revalidate | undefined\n  swrDelta: SwrDelta | undefined\n}): Promise<void> {\n  if (isResSent(res)) {\n    return\n  }\n\n  if (poweredByHeader && type === 'html') {\n    res.setHeader('X-Powered-By', 'Next.js')\n  }\n\n  if (typeof revalidate !== 'undefined') {\n    res.setHeader(\n      'Cache-Control',\n      formatRevalidate({\n        revalidate,\n        swrDelta,\n      })\n    )\n  }\n\n  const payload = result.isDynamic ? null : result.toUnchunkedString()\n\n  if (payload !== null) {\n    let etagPayload = payload\n    if (type === 'rsc') {\n      // ensure etag generation is deterministic as\n      // ordering can differ even if underlying content\n      // does not differ\n      etagPayload = payload.split('\\n').sort().join('\\n')\n    } else if (type === 'html' && payload.includes('__next_f')) {\n      const { parse } =\n        require('next/dist/compiled/node-html-parser') as typeof import('next/dist/compiled/node-html-parser')\n\n      try {\n        // Parse the HTML\n        let root = parse(payload)\n\n        // Get script tags in the body element\n        let scriptTags = root\n          .querySelector('body')\n          ?.querySelectorAll('script')\n          .filter(\n            (node) =>\n              !node.hasAttribute('src') && node.innerHTML?.includes('__next_f')\n          )\n\n        // Sort the script tags by their inner text\n        scriptTags?.sort((a, b) => a.innerHTML.localeCompare(b.innerHTML))\n\n        // Remove the original script tags\n        scriptTags?.forEach((script: any) => script.remove())\n\n        // Append the sorted script tags to the body\n        scriptTags?.forEach((script: any) =>\n          root.querySelector('body')?.appendChild(script)\n        )\n\n        // Stringify back to HTML\n        etagPayload = root.toString()\n      } catch (err) {\n        console.error(`Error parsing HTML payload`, err)\n      }\n    }\n\n    const etag = generateEtags ? generateETag(etagPayload) : undefined\n    if (sendEtagResponse(req, res, etag)) {\n      return\n    }\n  }\n\n  if (!res.getHeader('Content-Type')) {\n    res.setHeader(\n      'Content-Type',\n      result.contentType\n        ? result.contentType\n        : type === 'rsc'\n          ? RSC_CONTENT_TYPE_HEADER\n          : type === 'json'\n            ? 'application/json'\n            : 'text/html; charset=utf-8'\n    )\n  }\n\n  if (payload) {\n    res.setHeader('Content-Length', Buffer.byteLength(payload))\n  }\n\n  if (req.method === 'HEAD') {\n    res.end(null)\n    return\n  }\n\n  if (payload !== null) {\n    res.end(payload)\n    return\n  }\n\n  // Pipe the render result to the response after we get a writer for it.\n  await result.pipeToNodeResponse(res)\n}\n"],"names":["sendEtagResponse","sendRenderResult","req","res","etag","setHeader","fresh","headers","statusCode","end","result","type","generateEtags","poweredByHeader","revalidate","swrDelta","isResSent","formatRevalidate","payload","isDynamic","toUnchunkedString","etagPayload","split","sort","join","includes","parse","require","root","scriptTags","querySelector","querySelectorAll","filter","node","hasAttribute","innerHTML","a","b","localeCompare","forEach","script","remove","appendChild","toString","err","console","error","generateETag","undefined","getHeader","contentType","RSC_CONTENT_TYPE_HEADER","Buffer","byteLength","method","pipeToNodeResponse"],"mappings":"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"}