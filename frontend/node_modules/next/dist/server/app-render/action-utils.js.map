{"version":3,"sources":["../../../src/server/app-render/action-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\n\n// This function creates a Flight-acceptable server module map proxy from our\n// Server Reference Manifest similar to our client module map.\n// This is because our manifest contains a lot of internal Next.js data that\n// are relevant to the runtime, workers, etc. that React doesn't need to know.\nexport function createServerModuleMap({\n  serverActionsManifest,\n  pageName,\n}: {\n  serverActionsManifest: ActionManifest\n  pageName: string\n}) {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        return {\n          id: serverActionsManifest[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ][id].workers[normalizeWorkerPageName(pageName)],\n          name: id,\n          chunks: [],\n        }\n      },\n    }\n  )\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string,\n  serverActionsManifest: ActionManifest\n) {\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n  const workerName = normalizeWorkerPageName(pageName)\n\n  // no workers, nothing to forward to\n  if (!workers) return\n\n  // if there is a worker for this page, no need to forward it.\n  if (workers[workerName]) {\n    return\n  }\n\n  // otherwise, grab the first worker that has a handler for this action id\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\n/**\n * The flight entry loader keys actions by bundlePath.\n * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n"],"names":["createServerModuleMap","selectWorkerForForwarding","serverActionsManifest","pageName","Proxy","get","_","id","process","env","NEXT_RUNTIME","workers","normalizeWorkerPageName","name","chunks","actionId","workerName","denormalizeWorkerPageName","Object","keys","pathHasPrefix","bundlePath","normalizeAppPath","removePathPrefix"],"mappings":";;;;;;;;;;;;;;;IASgBA,qBAAqB;eAArBA;;IA2BAC,yBAAyB;eAAzBA;;;0BAnCiB;+BACH;kCACG;AAM1B,SAASD,sBAAsB,EACpCE,qBAAqB,EACrBC,QAAQ,EAIT;IACC,OAAO,IAAIC,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;YACP,OAAO;gBACLA,IAAIL,qBAAqB,CACvBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,SAAS,OAChD,CAACH,GAAG,CAACI,OAAO,CAACC,wBAAwBT,UAAU;gBAChDU,MAAMN;gBACNO,QAAQ,EAAE;YACZ;QACF;IACF;AAEJ;AAMO,SAASb,0BACdc,QAAgB,EAChBZ,QAAgB,EAChBD,qBAAqC;QAGnCA;IADF,MAAMS,WACJT,mCAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,SAAS,OAChD,CAACK,SAAS,qBAFXb,iCAEaS,OAAO;IACtB,MAAMK,aAAaJ,wBAAwBT;IAE3C,oCAAoC;IACpC,IAAI,CAACQ,SAAS;IAEd,6DAA6D;IAC7D,IAAIA,OAAO,CAACK,WAAW,EAAE;QACvB;IACF;IAEA,yEAAyE;IACzE,OAAOC,0BAA0BC,OAAOC,IAAI,CAACR,QAAQ,CAAC,EAAE;AAC1D;AAEA;;;CAGC,GACD,SAASC,wBAAwBT,QAAgB;IAC/C,IAAIiB,IAAAA,4BAAa,EAACjB,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;CAEC,GACD,SAASc,0BAA0BI,UAAkB;IACnD,OAAOC,IAAAA,0BAAgB,EAACC,IAAAA,kCAAgB,EAACF,YAAY;AACvD"}