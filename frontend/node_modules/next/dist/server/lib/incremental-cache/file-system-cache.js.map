{"version":3,"sources":["../../../../src/server/lib/incremental-cache/file-system-cache.ts"],"sourcesContent":["import type { RouteMetadata } from '../../../export/routes/types'\nimport type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from './'\nimport type { CacheFs } from '../../../shared/lib/utils'\nimport type { CachedFetchValue } from '../../response-cache'\n\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from '../../../shared/lib/isomorphic/path'\nimport {\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_DATA_SUFFIX,\n  NEXT_META_SUFFIX,\n  RSC_PREFETCH_SUFFIX,\n  RSC_SUFFIX,\n} from '../../../lib/constants'\n\ntype FileSystemCacheContext = Omit<\n  CacheHandlerContext,\n  'fs' | 'serverDistDir'\n> & {\n  fs: CacheFs\n  serverDistDir: string\n}\n\ntype TagsManifest = {\n  version: 1\n  items: { [tag: string]: { revalidatedAt: number } }\n}\nlet memoryCache: LRUCache<string, CacheHandlerValue> | undefined\nlet tagsManifest: TagsManifest | undefined\n\nexport default class FileSystemCache implements CacheHandler {\n  private fs: FileSystemCacheContext['fs']\n  private flushToDisk?: FileSystemCacheContext['flushToDisk']\n  private serverDistDir: FileSystemCacheContext['serverDistDir']\n  private appDir: boolean\n  private pagesDir: boolean\n  private tagsManifestPath?: string\n  private revalidatedTags: string[]\n  private debug: boolean\n\n  constructor(ctx: FileSystemCacheContext) {\n    this.fs = ctx.fs\n    this.flushToDisk = ctx.flushToDisk\n    this.serverDistDir = ctx.serverDistDir\n    this.appDir = !!ctx._appDir\n    this.pagesDir = !!ctx._pagesDir\n    this.revalidatedTags = ctx.revalidatedTags\n    this.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n\n    if (ctx.maxMemoryCacheSize) {\n      if (!memoryCache) {\n        if (this.debug) {\n          console.log('using memory store for fetch cache')\n        }\n\n        memoryCache = new LRUCache({\n          max: ctx.maxMemoryCacheSize,\n          length({ value }) {\n            if (!value) {\n              return 25\n            } else if (value.kind === 'REDIRECT') {\n              return JSON.stringify(value.props).length\n            } else if (value.kind === 'IMAGE') {\n              throw new Error('invariant image should not be incremental-cache')\n            } else if (value.kind === 'FETCH') {\n              return JSON.stringify(value.data || '').length\n            } else if (value.kind === 'ROUTE') {\n              return value.body.length\n            }\n            // rough estimate of size of cache value\n            return (\n              value.html.length +\n              (JSON.stringify(\n                value.kind === 'APP_PAGE' ? value.rscData : value.pageData\n              )?.length || 0)\n            )\n          },\n        })\n      }\n    } else if (this.debug) {\n      console.log('not using memory store for fetch cache')\n    }\n\n    if (this.serverDistDir && this.fs) {\n      this.tagsManifestPath = path.join(\n        this.serverDistDir,\n        '..',\n        'cache',\n        'fetch-cache',\n        'tags-manifest.json'\n      )\n\n      this.loadTagsManifestSync()\n    }\n  }\n\n  public resetRequestCache(): void {}\n\n  /**\n   * Load the tags manifest from the file system\n   */\n  private async loadTagsManifest() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return\n    try {\n      tagsManifest = JSON.parse(\n        await this.fs.readFile(this.tagsManifestPath, 'utf8')\n      )\n    } catch (err: any) {\n      tagsManifest = { version: 1, items: {} }\n    }\n    if (this.debug) console.log('loadTagsManifest', tagsManifest)\n  }\n\n  /**\n   * As above, but synchronous for use in the constructor. This is to\n   * preserve the existing behaviour when instantiating the cache handler. Although it's\n   * not ideal to block the main thread it's only called once during startup.\n   */\n  private loadTagsManifestSync() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return\n    try {\n      tagsManifest = JSON.parse(\n        this.fs.readFileSync(this.tagsManifestPath, 'utf8')\n      )\n    } catch (err: any) {\n      tagsManifest = { version: 1, items: {} }\n    }\n    if (this.debug) console.log('loadTagsManifest', tagsManifest)\n  }\n\n  public async revalidateTag(\n    ...args: Parameters<CacheHandler['revalidateTag']>\n  ) {\n    let [tags] = args\n    tags = typeof tags === 'string' ? [tags] : tags\n\n    if (this.debug) {\n      console.log('revalidateTag', tags)\n    }\n\n    if (tags.length === 0) {\n      return\n    }\n\n    // we need to ensure the tagsManifest is refreshed\n    // since separate workers can be updating it at the same\n    // time and we can't flush out of sync data\n    await this.loadTagsManifest()\n    if (!tagsManifest || !this.tagsManifestPath) {\n      return\n    }\n\n    for (const tag of tags) {\n      const data = tagsManifest.items[tag] || {}\n      data.revalidatedAt = Date.now()\n      tagsManifest.items[tag] = data\n    }\n\n    try {\n      await this.fs.mkdir(path.dirname(this.tagsManifestPath))\n      await this.fs.writeFile(\n        this.tagsManifestPath,\n        JSON.stringify(tagsManifest || {})\n      )\n      if (this.debug) {\n        console.log('Updated tags manifest', tagsManifest)\n      }\n    } catch (err: any) {\n      console.warn('Failed to update tags manifest.', err)\n    }\n  }\n\n  public async get(...args: Parameters<CacheHandler['get']>) {\n    const [key, ctx = {}] = args\n    const { tags, softTags, kindHint, isRoutePPREnabled } = ctx\n    let data = memoryCache?.get(key)\n\n    if (this.debug) {\n      console.log('get', key, tags, kindHint, !!data)\n    }\n\n    // let's check the disk for seed data\n    if (!data && process.env.NEXT_RUNTIME !== 'edge') {\n      try {\n        const filePath = this.getFilePath(`${key}.body`, 'app')\n        const fileData = await this.fs.readFile(filePath)\n        const { mtime } = await this.fs.stat(filePath)\n\n        const meta = JSON.parse(\n          await this.fs.readFile(\n            filePath.replace(/\\.body$/, NEXT_META_SUFFIX),\n            'utf8'\n          )\n        )\n\n        const cacheEntry: CacheHandlerValue = {\n          lastModified: mtime.getTime(),\n          value: {\n            kind: 'ROUTE',\n            body: fileData,\n            headers: meta.headers,\n            status: meta.status,\n          },\n        }\n        return cacheEntry\n      } catch (_) {\n        // no .meta data for the related key\n      }\n\n      try {\n        // Determine the file kind if we didn't know it already.\n        let kind = kindHint\n        if (!kind) {\n          kind = this.detectFileKind(`${key}.html`)\n        }\n\n        const isAppPath = kind === 'app'\n        const filePath = this.getFilePath(\n          kind === 'fetch' ? key : `${key}.html`,\n          kind\n        )\n\n        const fileData = await this.fs.readFile(filePath, 'utf8')\n        const { mtime } = await this.fs.stat(filePath)\n\n        if (kind === 'fetch' && this.flushToDisk) {\n          const lastModified = mtime.getTime()\n          const parsedData: CachedFetchValue = JSON.parse(fileData)\n          data = {\n            lastModified,\n            value: parsedData,\n          }\n\n          if (data.value?.kind === 'FETCH') {\n            const storedTags = data.value?.tags\n\n            // update stored tags if a new one is being added\n            // TODO: remove this when we can send the tags\n            // via header on GET same as SET\n            if (!tags?.every((tag) => storedTags?.includes(tag))) {\n              if (this.debug) {\n                console.log('tags vs storedTags mismatch', tags, storedTags)\n              }\n              await this.set(key, data.value, {\n                tags,\n                isRoutePPREnabled,\n              })\n            }\n          }\n        } else {\n          let meta: RouteMetadata | undefined\n\n          if (isAppPath) {\n            try {\n              meta = JSON.parse(\n                await this.fs.readFile(\n                  filePath.replace(/\\.html$/, NEXT_META_SUFFIX),\n                  'utf8'\n                )\n              )\n            } catch {}\n          }\n\n          if (isAppPath) {\n            const rscData = await this.fs.readFile(\n              this.getFilePath(\n                `${key}${isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,\n                'app'\n              )\n            )\n            data = {\n              lastModified: mtime.getTime(),\n              value: {\n                kind: 'APP_PAGE',\n                html: fileData,\n                rscData,\n                postponed: meta?.postponed,\n                headers: meta?.headers,\n                status: meta?.status,\n              },\n            }\n          } else {\n            const pageData = JSON.parse(\n              await this.fs.readFile(\n                this.getFilePath(`${key}${NEXT_DATA_SUFFIX}`, 'pages'),\n                'utf8'\n              )\n            )\n\n            data = {\n              lastModified: mtime.getTime(),\n              value: {\n                kind: 'PAGE',\n                html: fileData,\n                pageData,\n                headers: meta?.headers,\n                status: meta?.status,\n              },\n            }\n          }\n        }\n\n        if (data) {\n          memoryCache?.set(key, data)\n        }\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n\n    if (data?.value?.kind === 'APP_PAGE' || data?.value?.kind === 'PAGE') {\n      let cacheTags: undefined | string[]\n      const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]\n\n      if (typeof tagsHeader === 'string') {\n        cacheTags = tagsHeader.split(',')\n      }\n\n      if (cacheTags?.length) {\n        await this.loadTagsManifest()\n\n        const isStale = cacheTags.some((tag) => {\n          return (\n            tagsManifest?.items[tag]?.revalidatedAt &&\n            tagsManifest?.items[tag].revalidatedAt >=\n              (data?.lastModified || Date.now())\n          )\n        })\n\n        // we trigger a blocking validation if an ISR page\n        // had a tag revalidated, if we want to be a background\n        // revalidation instead we return data.lastModified = -1\n        if (isStale) {\n          data = undefined\n        }\n      }\n    }\n\n    if (data && data?.value?.kind === 'FETCH') {\n      await this.loadTagsManifest()\n\n      const combinedTags = [...(tags || []), ...(softTags || [])]\n\n      const wasRevalidated = combinedTags.some((tag) => {\n        if (this.revalidatedTags.includes(tag)) {\n          return true\n        }\n\n        return (\n          tagsManifest?.items[tag]?.revalidatedAt &&\n          tagsManifest?.items[tag].revalidatedAt >=\n            (data?.lastModified || Date.now())\n        )\n      })\n      // When revalidate tag is called we don't return\n      // stale data so it's updated right away\n      if (wasRevalidated) {\n        data = undefined\n      }\n    }\n\n    return data ?? null\n  }\n\n  public async set(...args: Parameters<CacheHandler['set']>) {\n    const [key, data, ctx] = args\n    memoryCache?.set(key, {\n      value: data,\n      lastModified: Date.now(),\n    })\n    if (this.debug) {\n      console.log('set', key)\n    }\n\n    if (!this.flushToDisk) return\n\n    if (data?.kind === 'ROUTE') {\n      const filePath = this.getFilePath(`${key}.body`, 'app')\n      await this.fs.mkdir(path.dirname(filePath))\n      await this.fs.writeFile(filePath, data.body)\n\n      const meta: RouteMetadata = {\n        headers: data.headers,\n        status: data.status,\n        postponed: undefined,\n      }\n\n      await this.fs.writeFile(\n        filePath.replace(/\\.body$/, NEXT_META_SUFFIX),\n        JSON.stringify(meta, null, 2)\n      )\n      return\n    }\n\n    if (data?.kind === 'PAGE' || data?.kind === 'APP_PAGE') {\n      const isAppPath = data.kind === 'APP_PAGE'\n      const htmlPath = this.getFilePath(\n        `${key}.html`,\n        isAppPath ? 'app' : 'pages'\n      )\n      await this.fs.mkdir(path.dirname(htmlPath))\n      await this.fs.writeFile(htmlPath, data.html)\n\n      await this.fs.writeFile(\n        this.getFilePath(\n          `${key}${\n            isAppPath\n              ? ctx.isRoutePPREnabled\n                ? RSC_PREFETCH_SUFFIX\n                : RSC_SUFFIX\n              : NEXT_DATA_SUFFIX\n          }`,\n          isAppPath ? 'app' : 'pages'\n        ),\n        isAppPath ? data.rscData : JSON.stringify(data.pageData)\n      )\n\n      if (data.headers || data.status || (isAppPath && data.postponed)) {\n        const meta: RouteMetadata = {\n          headers: data.headers,\n          status: data.status,\n          postponed: isAppPath ? data.postponed : undefined,\n        }\n\n        await this.fs.writeFile(\n          htmlPath.replace(/\\.html$/, NEXT_META_SUFFIX),\n          JSON.stringify(meta)\n        )\n      }\n    } else if (data?.kind === 'FETCH') {\n      const filePath = this.getFilePath(key, 'fetch')\n      await this.fs.mkdir(path.dirname(filePath))\n      await this.fs.writeFile(\n        filePath,\n        JSON.stringify({\n          ...data,\n          tags: ctx.tags,\n        })\n      )\n    }\n  }\n\n  private detectFileKind(pathname: string) {\n    if (!this.appDir && !this.pagesDir) {\n      throw new Error(\n        \"Invariant: Can't determine file path kind, no page directory enabled\"\n      )\n    }\n\n    // If app directory isn't enabled, then assume it's pages and avoid the fs\n    // hit.\n    if (!this.appDir && this.pagesDir) {\n      return 'pages'\n    }\n    // Otherwise assume it's a pages file if the pages directory isn't enabled.\n    else if (this.appDir && !this.pagesDir) {\n      return 'app'\n    }\n\n    // If both are enabled, we need to test each in order, starting with\n    // `pages`.\n    let filePath = this.getFilePath(pathname, 'pages')\n    if (this.fs.existsSync(filePath)) {\n      return 'pages'\n    }\n\n    filePath = this.getFilePath(pathname, 'app')\n    if (this.fs.existsSync(filePath)) {\n      return 'app'\n    }\n\n    throw new Error(\n      `Invariant: Unable to determine file path kind for ${pathname}`\n    )\n  }\n\n  private getFilePath(\n    pathname: string,\n    kind: 'app' | 'fetch' | 'pages'\n  ): string {\n    switch (kind) {\n      case 'fetch':\n        // we store in .next/cache/fetch-cache so it can be persisted\n        // across deploys\n        return path.join(\n          this.serverDistDir,\n          '..',\n          'cache',\n          'fetch-cache',\n          pathname\n        )\n      case 'pages':\n        return path.join(this.serverDistDir, 'pages', pathname)\n      case 'app':\n        return path.join(this.serverDistDir, 'app', pathname)\n      default:\n        throw new Error(\"Invariant: Can't determine file path kind\")\n    }\n  }\n}\n"],"names":["FileSystemCache","memoryCache","tagsManifest","constructor","ctx","fs","flushToDisk","serverDistDir","appDir","_appDir","pagesDir","_pagesDir","revalidatedTags","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","maxMemoryCacheSize","console","log","LRUCache","max","length","value","JSON","kind","stringify","props","Error","data","body","html","rscData","pageData","tagsManifestPath","path","join","loadTagsManifestSync","resetRequestCache","loadTagsManifest","parse","readFile","err","version","items","readFileSync","revalidateTag","args","tags","tag","revalidatedAt","Date","now","mkdir","dirname","writeFile","warn","get","key","softTags","kindHint","isRoutePPREnabled","NEXT_RUNTIME","filePath","getFilePath","fileData","mtime","stat","meta","replace","NEXT_META_SUFFIX","cacheEntry","lastModified","getTime","headers","status","_","detectFileKind","isAppPath","parsedData","storedTags","every","includes","set","RSC_PREFETCH_SUFFIX","RSC_SUFFIX","postponed","NEXT_DATA_SUFFIX","cacheTags","tagsHeader","NEXT_CACHE_TAGS_HEADER","split","isStale","some","undefined","combinedTags","wasRevalidated","htmlPath","pathname","existsSync"],"mappings":"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"}