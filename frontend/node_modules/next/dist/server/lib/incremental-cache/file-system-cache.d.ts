import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from './';
import type { CacheFs } from '../../../shared/lib/utils';
type FileSystemCacheContext = Omit<CacheHandlerContext, 'fs' | 'serverDistDir'> & {
    fs: CacheFs;
    serverDistDir: string;
};
export default class FileSystemCache implements CacheHandler {
    private fs;
    private flushToDisk?;
    private serverDistDir;
    private appDir;
    private pagesDir;
    private tagsManifestPath?;
    private revalidatedTags;
    private debug;
    constructor(ctx: FileSystemCacheContext);
    resetRequestCache(): void;
    /**
     * Load the tags manifest from the file system
     */
    private loadTagsManifest;
    /**
     * As above, but synchronous for use in the constructor. This is to
     * preserve the existing behaviour when instantiating the cache handler. Although it's
     * not ideal to block the main thread it's only called once during startup.
     */
    private loadTagsManifestSync;
    revalidateTag(...args: Parameters<CacheHandler['revalidateTag']>): Promise<void>;
    get(...args: Parameters<CacheHandler['get']>): Promise<CacheHandlerValue | null>;
    set(...args: Parameters<CacheHandler['set']>): Promise<void>;
    private detectFileKind;
    private getFilePath;
}
export {};
