{"version":3,"sources":["../../../../src/server/lib/incremental-cache/fetch-cache.ts"],"sourcesContent":["import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from './'\nimport type { IncrementalCacheValue } from '../../response-cache'\n\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport {\n  CACHE_ONE_YEAR,\n  NEXT_CACHE_SOFT_TAGS_HEADER,\n} from '../../../lib/constants'\n\nlet rateLimitedUntil = 0\nlet memoryCache: LRUCache<string, CacheHandlerValue> | undefined\n\ninterface NextFetchCacheParams {\n  internal?: boolean\n  fetchType?: string\n  fetchIdx?: number\n  fetchUrl?: string\n}\n\nconst CACHE_TAGS_HEADER = 'x-vercel-cache-tags' as const\nconst CACHE_HEADERS_HEADER = 'x-vercel-sc-headers' as const\nconst CACHE_STATE_HEADER = 'x-vercel-cache-state' as const\nconst CACHE_REVALIDATE_HEADER = 'x-vercel-revalidate' as const\nconst CACHE_FETCH_URL_HEADER = 'x-vercel-cache-item-name' as const\nconst CACHE_CONTROL_VALUE_HEADER = 'x-vercel-cache-control' as const\n\nconst DEBUG = Boolean(process.env.NEXT_PRIVATE_DEBUG_CACHE)\n\nasync function fetchRetryWithTimeout(\n  url: Parameters<typeof fetch>[0],\n  init: Parameters<typeof fetch>[1],\n  retryIndex = 0\n): Promise<Response> {\n  const controller = new AbortController()\n  const timeout = setTimeout(() => {\n    controller.abort()\n  }, 500)\n\n  return fetch(url, {\n    ...(init || {}),\n    signal: controller.signal,\n  })\n    .catch((err) => {\n      if (retryIndex === 3) {\n        throw err\n      } else {\n        if (DEBUG) {\n          console.log(`Fetch failed for ${url} retry ${retryIndex}`)\n        }\n        return fetchRetryWithTimeout(url, init, retryIndex + 1)\n      }\n    })\n    .finally(() => {\n      clearTimeout(timeout)\n    })\n}\n\nexport default class FetchCache implements CacheHandler {\n  private headers: Record<string, string>\n  private cacheEndpoint?: string\n\n  private hasMatchingTags(arr1: string[], arr2: string[]) {\n    if (arr1.length !== arr2.length) return false\n\n    const set1 = new Set(arr1)\n    const set2 = new Set(arr2)\n\n    if (set1.size !== set2.size) return false\n\n    for (let tag of set1) {\n      if (!set2.has(tag)) return false\n    }\n\n    return true\n  }\n\n  static isAvailable(ctx: {\n    _requestHeaders: CacheHandlerContext['_requestHeaders']\n  }) {\n    return !!(\n      ctx._requestHeaders['x-vercel-sc-host'] || process.env.SUSPENSE_CACHE_URL\n    )\n  }\n\n  constructor(ctx: CacheHandlerContext) {\n    this.headers = {}\n    this.headers['Content-Type'] = 'application/json'\n\n    if (CACHE_HEADERS_HEADER in ctx._requestHeaders) {\n      const newHeaders = JSON.parse(\n        ctx._requestHeaders[CACHE_HEADERS_HEADER] as string\n      )\n      for (const k in newHeaders) {\n        this.headers[k] = newHeaders[k]\n      }\n      delete ctx._requestHeaders[CACHE_HEADERS_HEADER]\n    }\n    const scHost =\n      ctx._requestHeaders['x-vercel-sc-host'] || process.env.SUSPENSE_CACHE_URL\n\n    const scBasePath =\n      ctx._requestHeaders['x-vercel-sc-basepath'] ||\n      process.env.SUSPENSE_CACHE_BASEPATH\n\n    if (process.env.SUSPENSE_CACHE_AUTH_TOKEN) {\n      this.headers['Authorization'] =\n        `Bearer ${process.env.SUSPENSE_CACHE_AUTH_TOKEN}`\n    }\n\n    if (scHost) {\n      const scProto = process.env.SUSPENSE_CACHE_PROTO || 'https'\n      this.cacheEndpoint = `${scProto}://${scHost}${scBasePath || ''}`\n      if (DEBUG) {\n        console.log('using cache endpoint', this.cacheEndpoint)\n      }\n    } else if (DEBUG) {\n      console.log('no cache endpoint available')\n    }\n\n    if (ctx.maxMemoryCacheSize) {\n      if (!memoryCache) {\n        if (DEBUG) {\n          console.log('using memory store for fetch cache')\n        }\n\n        memoryCache = new LRUCache({\n          max: ctx.maxMemoryCacheSize,\n          length({ value }) {\n            if (!value) {\n              return 25\n            } else if (value.kind === 'REDIRECT') {\n              return JSON.stringify(value.props).length\n            } else if (value.kind === 'IMAGE') {\n              throw new Error('invariant image should not be incremental-cache')\n            } else if (value.kind === 'FETCH') {\n              return JSON.stringify(value.data || '').length\n            } else if (value.kind === 'ROUTE') {\n              return value.body.length\n            }\n            // rough estimate of size of cache value\n            return (\n              value.html.length +\n              (JSON.stringify(\n                value.kind === 'APP_PAGE' ? value.rscData : value.pageData\n              )?.length || 0)\n            )\n          },\n        })\n      }\n    } else {\n      if (DEBUG) {\n        console.log('not using memory store for fetch cache')\n      }\n    }\n  }\n\n  public resetRequestCache(): void {\n    memoryCache?.reset()\n  }\n\n  public async revalidateTag(\n    ...args: Parameters<CacheHandler['revalidateTag']>\n  ) {\n    let [tags] = args\n    tags = typeof tags === 'string' ? [tags] : tags\n    if (DEBUG) {\n      console.log('revalidateTag', tags)\n    }\n\n    if (!tags.length) return\n\n    if (Date.now() < rateLimitedUntil) {\n      if (DEBUG) {\n        console.log('rate limited ', rateLimitedUntil)\n      }\n      return\n    }\n\n    try {\n      const res = await fetchRetryWithTimeout(\n        `${this.cacheEndpoint}/v1/suspense-cache/revalidate?tags=${tags\n          .map((tag) => encodeURIComponent(tag))\n          .join(',')}`,\n        {\n          method: 'POST',\n          headers: this.headers,\n          // @ts-expect-error not on public type\n          next: { internal: true },\n        }\n      )\n\n      if (res.status === 429) {\n        const retryAfter = res.headers.get('retry-after') || '60000'\n        rateLimitedUntil = Date.now() + parseInt(retryAfter)\n      }\n\n      if (!res.ok) {\n        throw new Error(`Request failed with status ${res.status}.`)\n      }\n    } catch (err) {\n      console.warn(`Failed to revalidate tag ${tags}`, err)\n    }\n  }\n\n  public async get(...args: Parameters<CacheHandler['get']>) {\n    const [key, ctx = {}] = args\n    const { tags, softTags, kindHint, fetchIdx, fetchUrl } = ctx\n\n    if (kindHint !== 'fetch') {\n      return null\n    }\n\n    if (Date.now() < rateLimitedUntil) {\n      if (DEBUG) {\n        console.log('rate limited')\n      }\n      return null\n    }\n\n    // memory cache is cleared at the end of each request\n    // so that revalidate events are pulled from upstream\n    // on successive requests\n    let data = memoryCache?.get(key)\n\n    const hasFetchKindAndMatchingTags =\n      data?.value?.kind === 'FETCH' &&\n      this.hasMatchingTags(tags ?? [], data.value.tags ?? [])\n\n    // Get data from fetch cache. Also check if new tags have been\n    // specified with the same cache key (fetch URL)\n    if (this.cacheEndpoint && (!data || !hasFetchKindAndMatchingTags)) {\n      try {\n        const start = Date.now()\n        const fetchParams: NextFetchCacheParams = {\n          internal: true,\n          fetchType: 'cache-get',\n          fetchUrl: fetchUrl,\n          fetchIdx,\n        }\n        const res = await fetch(\n          `${this.cacheEndpoint}/v1/suspense-cache/${key}`,\n          {\n            method: 'GET',\n            headers: {\n              ...this.headers,\n              [CACHE_FETCH_URL_HEADER]: fetchUrl,\n              [CACHE_TAGS_HEADER]: tags?.join(',') || '',\n              [NEXT_CACHE_SOFT_TAGS_HEADER]: softTags?.join(',') || '',\n            } as any,\n            next: fetchParams as NextFetchRequestConfig,\n          }\n        )\n\n        if (res.status === 429) {\n          const retryAfter = res.headers.get('retry-after') || '60000'\n          rateLimitedUntil = Date.now() + parseInt(retryAfter)\n        }\n\n        if (res.status === 404) {\n          if (DEBUG) {\n            console.log(\n              `no fetch cache entry for ${key}, duration: ${\n                Date.now() - start\n              }ms`\n            )\n          }\n          return null\n        }\n\n        if (!res.ok) {\n          console.error(await res.text())\n          throw new Error(`invalid response from cache ${res.status}`)\n        }\n\n        const cached: IncrementalCacheValue = await res.json()\n\n        if (!cached || cached.kind !== 'FETCH') {\n          DEBUG && console.log({ cached })\n          throw new Error('invalid cache value')\n        }\n\n        // if new tags were specified, merge those tags to the existing tags\n        if (cached.kind === 'FETCH') {\n          cached.tags ??= []\n          for (const tag of tags ?? []) {\n            if (!cached.tags.includes(tag)) {\n              cached.tags.push(tag)\n            }\n          }\n        }\n\n        const cacheState = res.headers.get(CACHE_STATE_HEADER)\n        const age = res.headers.get('age')\n\n        data = {\n          value: cached,\n          // if it's already stale set it to a time in the past\n          // if not derive last modified from age\n          lastModified:\n            cacheState !== 'fresh'\n              ? Date.now() - CACHE_ONE_YEAR\n              : Date.now() - parseInt(age || '0', 10) * 1000,\n        }\n\n        if (DEBUG) {\n          console.log(\n            `got fetch cache entry for ${key}, duration: ${\n              Date.now() - start\n            }ms, size: ${\n              Object.keys(cached).length\n            }, cache-state: ${cacheState} tags: ${tags?.join(\n              ','\n            )} softTags: ${softTags?.join(',')}`\n          )\n        }\n\n        if (data) {\n          memoryCache?.set(key, data)\n        }\n      } catch (err) {\n        // unable to get data from fetch-cache\n        if (DEBUG) {\n          console.error(`Failed to get from fetch-cache`, err)\n        }\n      }\n    }\n\n    return data || null\n  }\n\n  public async set(...args: Parameters<CacheHandler['set']>) {\n    const [key, data, ctx] = args\n\n    const newValue = data?.kind === 'FETCH' ? data.data : undefined\n    const existingCache = memoryCache?.get(key)\n    const existingValue = existingCache?.value\n    if (\n      existingValue?.kind === 'FETCH' &&\n      Object.keys(existingValue.data).every(\n        (field) =>\n          JSON.stringify(\n            (existingValue.data as Record<string, string | Object>)[field]\n          ) ===\n          JSON.stringify((newValue as Record<string, string | Object>)[field])\n      )\n    ) {\n      if (DEBUG) {\n        console.log(`skipping cache set for ${key} as not modified`)\n      }\n      return\n    }\n\n    const { fetchCache, fetchIdx, fetchUrl, tags } = ctx\n    if (!fetchCache) return\n\n    if (Date.now() < rateLimitedUntil) {\n      if (DEBUG) {\n        console.log('rate limited')\n      }\n      return\n    }\n\n    memoryCache?.set(key, {\n      value: data,\n      lastModified: Date.now(),\n    })\n\n    if (this.cacheEndpoint) {\n      try {\n        const start = Date.now()\n        if (data !== null && 'revalidate' in data) {\n          this.headers[CACHE_REVALIDATE_HEADER] = data.revalidate.toString()\n        }\n        if (\n          !this.headers[CACHE_REVALIDATE_HEADER] &&\n          data !== null &&\n          'data' in data\n        ) {\n          this.headers[CACHE_CONTROL_VALUE_HEADER] =\n            data.data.headers['cache-control']\n        }\n        const body = JSON.stringify({\n          ...data,\n          // we send the tags in the header instead\n          // of in the body here\n          tags: undefined,\n        })\n\n        if (DEBUG) {\n          console.log('set cache', key)\n        }\n        const fetchParams: NextFetchCacheParams = {\n          internal: true,\n          fetchType: 'cache-set',\n          fetchUrl,\n          fetchIdx,\n        }\n        const res = await fetch(\n          `${this.cacheEndpoint}/v1/suspense-cache/${key}`,\n          {\n            method: 'POST',\n            headers: {\n              ...this.headers,\n              [CACHE_FETCH_URL_HEADER]: fetchUrl || '',\n              [CACHE_TAGS_HEADER]: tags?.join(',') || '',\n            },\n            body: body,\n            next: fetchParams as NextFetchRequestConfig,\n          }\n        )\n\n        if (res.status === 429) {\n          const retryAfter = res.headers.get('retry-after') || '60000'\n          rateLimitedUntil = Date.now() + parseInt(retryAfter)\n        }\n\n        if (!res.ok) {\n          DEBUG && console.log(await res.text())\n          throw new Error(`invalid response ${res.status}`)\n        }\n\n        if (DEBUG) {\n          console.log(\n            `successfully set to fetch-cache for ${key}, duration: ${\n              Date.now() - start\n            }ms, size: ${body.length}`\n          )\n        }\n      } catch (err) {\n        // unable to set to fetch-cache\n        if (DEBUG) {\n          console.error(`Failed to update fetch cache`, err)\n        }\n      }\n    }\n    return\n  }\n}\n"],"names":["FetchCache","rateLimitedUntil","memoryCache","CACHE_TAGS_HEADER","CACHE_HEADERS_HEADER","CACHE_STATE_HEADER","CACHE_REVALIDATE_HEADER","CACHE_FETCH_URL_HEADER","CACHE_CONTROL_VALUE_HEADER","DEBUG","Boolean","process","env","NEXT_PRIVATE_DEBUG_CACHE","fetchRetryWithTimeout","url","init","retryIndex","controller","AbortController","timeout","setTimeout","abort","fetch","signal","catch","err","console","log","finally","clearTimeout","hasMatchingTags","arr1","arr2","length","set1","Set","set2","size","tag","has","isAvailable","ctx","_requestHeaders","SUSPENSE_CACHE_URL","constructor","headers","newHeaders","JSON","parse","k","scHost","scBasePath","SUSPENSE_CACHE_BASEPATH","SUSPENSE_CACHE_AUTH_TOKEN","scProto","SUSPENSE_CACHE_PROTO","cacheEndpoint","maxMemoryCacheSize","LRUCache","max","value","kind","stringify","props","Error","data","body","html","rscData","pageData","resetRequestCache","reset","revalidateTag","args","tags","Date","now","res","map","encodeURIComponent","join","method","next","internal","status","retryAfter","get","parseInt","ok","warn","key","softTags","kindHint","fetchIdx","fetchUrl","hasFetchKindAndMatchingTags","start","fetchParams","fetchType","NEXT_CACHE_SOFT_TAGS_HEADER","error","text","cached","json","includes","push","cacheState","age","lastModified","CACHE_ONE_YEAR","Object","keys","set","newValue","undefined","existingCache","existingValue","every","field","fetchCache","revalidate","toString"],"mappings":"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"}