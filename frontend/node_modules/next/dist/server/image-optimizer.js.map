{"version":3,"sources":["../../src/server/image-optimizer.ts"],"sourcesContent":["import { createHash } from 'crypto'\nimport { promises } from 'fs'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport { mediaType } from 'next/dist/compiled/@hapi/accept'\nimport contentDisposition from 'next/dist/compiled/content-disposition'\nimport imageSizeOf from 'next/dist/compiled/image-size'\nimport isAnimated from 'next/dist/compiled/is-animated'\nimport { join } from 'path'\nimport nodeUrl, { type UrlWithParsedQuery } from 'url'\n\nimport { getImageBlurSvg } from '../shared/lib/image-blur-svg'\nimport type { ImageConfigComplete } from '../shared/lib/image-config'\nimport { hasMatch } from '../shared/lib/match-remote-pattern'\nimport type { NextConfigComplete } from './config-shared'\nimport { createRequestResponseMocks } from './lib/mock-request'\nimport type { NextUrlWithParsedQuery } from './request-meta'\nimport type {\n  IncrementalCacheEntry,\n  IncrementalCacheValue,\n} from './response-cache'\nimport { sendEtagResponse } from './send-payload'\nimport { getContentType, getExtension } from './serve-static'\nimport * as Log from '../build/output/log'\nimport isError from '../lib/is-error'\n\ntype XCacheHeader = 'MISS' | 'HIT' | 'STALE'\n\nconst AVIF = 'image/avif'\nconst WEBP = 'image/webp'\nconst PNG = 'image/png'\nconst JPEG = 'image/jpeg'\nconst GIF = 'image/gif'\nconst SVG = 'image/svg+xml'\nconst ICO = 'image/x-icon'\nconst TIFF = 'image/tiff'\nconst BMP = 'image/bmp'\nconst CACHE_VERSION = 3\nconst ANIMATABLE_TYPES = [WEBP, PNG, GIF]\nconst VECTOR_TYPES = [SVG]\nconst BLUR_IMG_SIZE = 8 // should match `next-image-loader`\nconst BLUR_QUALITY = 70 // should match `next-image-loader`\n\nlet _sharp: typeof import('sharp')\n\nfunction getSharp() {\n  if (_sharp) {\n    return _sharp\n  }\n  try {\n    _sharp = require('sharp')\n    if (_sharp && _sharp.concurrency() > 1) {\n      // Reducing concurrency should reduce the memory usage too.\n      // We more aggressively reduce in dev but also reduce in prod.\n      // https://sharp.pixelplumbing.com/api-utility#concurrency\n      const divisor = process.env.NODE_ENV === 'development' ? 4 : 2\n      _sharp.concurrency(\n        Math.floor(Math.max(_sharp.concurrency() / divisor, 1))\n      )\n    }\n  } catch (e: unknown) {\n    if (isError(e) && e.code === 'MODULE_NOT_FOUND') {\n      throw new Error(\n        'Module `sharp` not found. Please run `npm install --cpu=wasm32 sharp` to install it.'\n      )\n    }\n    throw e\n  }\n  return _sharp\n}\n\nexport interface ImageParamsResult {\n  href: string\n  isAbsolute: boolean\n  isStatic: boolean\n  width: number\n  quality: number\n  mimeType: string\n  sizes: number[]\n  minimumCacheTTL: number\n}\n\ninterface ImageUpstream {\n  buffer: Buffer\n  contentType: string | null | undefined\n  cacheControl: string | null | undefined\n}\n\nfunction getSupportedMimeType(options: string[], accept = ''): string {\n  const mimeType = mediaType(accept, options)\n  return accept.includes(mimeType) ? mimeType : ''\n}\n\nexport function getHash(items: (string | number | Buffer)[]) {\n  const hash = createHash('sha256')\n  for (let item of items) {\n    if (typeof item === 'number') hash.update(String(item))\n    else {\n      hash.update(item)\n    }\n  }\n  // See https://en.wikipedia.org/wiki/Base64#Filenames\n  return hash.digest('base64').replace(/\\//g, '-')\n}\n\nasync function writeToCacheDir(\n  dir: string,\n  extension: string,\n  maxAge: number,\n  expireAt: number,\n  buffer: Buffer,\n  etag: string\n) {\n  const filename = join(dir, `${maxAge}.${expireAt}.${etag}.${extension}`)\n\n  await promises.rm(dir, { recursive: true, force: true }).catch(() => {})\n\n  await promises.mkdir(dir, { recursive: true })\n  await promises.writeFile(filename, buffer)\n}\n\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nexport function detectContentType(buffer: Buffer) {\n  if ([0xff, 0xd8, 0xff].every((b, i) => buffer[i] === b)) {\n    return JPEG\n  }\n  if (\n    [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a].every(\n      (b, i) => buffer[i] === b\n    )\n  ) {\n    return PNG\n  }\n  if ([0x47, 0x49, 0x46, 0x38].every((b, i) => buffer[i] === b)) {\n    return GIF\n  }\n  if (\n    [0x52, 0x49, 0x46, 0x46, 0, 0, 0, 0, 0x57, 0x45, 0x42, 0x50].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return WEBP\n  }\n  if ([0x3c, 0x3f, 0x78, 0x6d, 0x6c].every((b, i) => buffer[i] === b)) {\n    return SVG\n  }\n  if ([0x3c, 0x73, 0x76, 0x67].every((b, i) => buffer[i] === b)) {\n    return SVG\n  }\n  if (\n    [0, 0, 0, 0, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return AVIF\n  }\n  if ([0x00, 0x00, 0x01, 0x00].every((b, i) => buffer[i] === b)) {\n    return ICO\n  }\n  if ([0x49, 0x49, 0x2a, 0x00].every((b, i) => buffer[i] === b)) {\n    return TIFF\n  }\n  if ([0x42, 0x4d].every((b, i) => buffer[i] === b)) {\n    return BMP\n  }\n  return null\n}\n\nexport class ImageOptimizerCache {\n  private cacheDir: string\n  private nextConfig: NextConfigComplete\n\n  static validateParams(\n    req: IncomingMessage,\n    query: UrlWithParsedQuery['query'],\n    nextConfig: NextConfigComplete,\n    isDev: boolean\n  ): ImageParamsResult | { errorMessage: string } {\n    const imageData = nextConfig.images\n    const {\n      deviceSizes = [],\n      imageSizes = [],\n      domains = [],\n      minimumCacheTTL = 60,\n      formats = ['image/webp'],\n    } = imageData\n    const remotePatterns = nextConfig.images?.remotePatterns || []\n    const { url, w, q } = query\n    let href: string\n\n    if (domains.length > 0) {\n      Log.warnOnce(\n        'The \"images.domains\" configuration is deprecated. Please use \"images.remotePatterns\" configuration instead.'\n      )\n    }\n\n    if (!url) {\n      return { errorMessage: '\"url\" parameter is required' }\n    } else if (Array.isArray(url)) {\n      return { errorMessage: '\"url\" parameter cannot be an array' }\n    }\n\n    if (url.length > 3072) {\n      return { errorMessage: '\"url\" parameter is too long' }\n    }\n\n    if (url.startsWith('//')) {\n      return {\n        errorMessage: '\"url\" parameter cannot be a protocol-relative URL (//)',\n      }\n    }\n\n    if (url.startsWith('/_next/image')) {\n      return {\n        errorMessage: '\"url\" parameter cannot be recursive',\n      }\n    }\n\n    let isAbsolute: boolean\n\n    if (url.startsWith('/')) {\n      href = url\n      isAbsolute = false\n    } else {\n      let hrefParsed: URL\n\n      try {\n        hrefParsed = new URL(url)\n        href = hrefParsed.toString()\n        isAbsolute = true\n      } catch (_error) {\n        return { errorMessage: '\"url\" parameter is invalid' }\n      }\n\n      if (!['http:', 'https:'].includes(hrefParsed.protocol)) {\n        return { errorMessage: '\"url\" parameter is invalid' }\n      }\n\n      if (!hasMatch(domains, remotePatterns, hrefParsed)) {\n        return { errorMessage: '\"url\" parameter is not allowed' }\n      }\n    }\n\n    if (!w) {\n      return { errorMessage: '\"w\" parameter (width) is required' }\n    } else if (Array.isArray(w)) {\n      return { errorMessage: '\"w\" parameter (width) cannot be an array' }\n    } else if (!/^[0-9]+$/.test(w)) {\n      return {\n        errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n      }\n    }\n\n    if (!q) {\n      return { errorMessage: '\"q\" parameter (quality) is required' }\n    } else if (Array.isArray(q)) {\n      return { errorMessage: '\"q\" parameter (quality) cannot be an array' }\n    } else if (!/^[0-9]+$/.test(q)) {\n      return {\n        errorMessage:\n          '\"q\" parameter (quality) must be an integer between 1 and 100',\n      }\n    }\n\n    const width = parseInt(w, 10)\n\n    if (width <= 0 || isNaN(width)) {\n      return {\n        errorMessage: '\"w\" parameter (width) must be an integer greater than 0',\n      }\n    }\n\n    const sizes = [...(deviceSizes || []), ...(imageSizes || [])]\n\n    if (isDev) {\n      sizes.push(BLUR_IMG_SIZE)\n    }\n\n    const isValidSize =\n      sizes.includes(width) || (isDev && width <= BLUR_IMG_SIZE)\n\n    if (!isValidSize) {\n      return {\n        errorMessage: `\"w\" parameter (width) of ${width} is not allowed`,\n      }\n    }\n\n    const quality = parseInt(q, 10)\n\n    if (isNaN(quality) || quality < 1 || quality > 100) {\n      return {\n        errorMessage:\n          '\"q\" parameter (quality) must be an integer between 1 and 100',\n      }\n    }\n\n    const mimeType = getSupportedMimeType(formats || [], req.headers['accept'])\n\n    const isStatic = url.startsWith(\n      `${nextConfig.basePath || ''}/_next/static/media`\n    )\n\n    return {\n      href,\n      sizes,\n      isAbsolute,\n      isStatic,\n      width,\n      quality,\n      mimeType,\n      minimumCacheTTL,\n    }\n  }\n\n  static getCacheKey({\n    href,\n    width,\n    quality,\n    mimeType,\n  }: {\n    href: string\n    width: number\n    quality: number\n    mimeType: string\n  }): string {\n    return getHash([CACHE_VERSION, href, width, quality, mimeType])\n  }\n\n  constructor({\n    distDir,\n    nextConfig,\n  }: {\n    distDir: string\n    nextConfig: NextConfigComplete\n  }) {\n    this.cacheDir = join(distDir, 'cache', 'images')\n    this.nextConfig = nextConfig\n  }\n\n  async get(cacheKey: string): Promise<IncrementalCacheEntry | null> {\n    try {\n      const cacheDir = join(this.cacheDir, cacheKey)\n      const files = await promises.readdir(cacheDir)\n      const now = Date.now()\n\n      for (const file of files) {\n        const [maxAgeSt, expireAtSt, etag, extension] = file.split('.', 4)\n        const buffer = await promises.readFile(join(cacheDir, file))\n        const expireAt = Number(expireAtSt)\n        const maxAge = Number(maxAgeSt)\n\n        return {\n          value: {\n            kind: 'IMAGE',\n            etag,\n            buffer,\n            extension,\n          },\n          revalidateAfter:\n            Math.max(maxAge, this.nextConfig.images.minimumCacheTTL) * 1000 +\n            Date.now(),\n          curRevalidate: maxAge,\n          isStale: now > expireAt,\n        }\n      }\n    } catch (_) {\n      // failed to read from cache dir, treat as cache miss\n    }\n    return null\n  }\n  async set(\n    cacheKey: string,\n    value: IncrementalCacheValue | null,\n    {\n      revalidate,\n    }: {\n      revalidate?: number | false\n    }\n  ) {\n    if (value?.kind !== 'IMAGE') {\n      throw new Error('invariant attempted to set non-image to image-cache')\n    }\n\n    if (typeof revalidate !== 'number') {\n      throw new Error('invariant revalidate must be a number for image-cache')\n    }\n    const expireAt =\n      Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 +\n      Date.now()\n\n    try {\n      await writeToCacheDir(\n        join(this.cacheDir, cacheKey),\n        value.extension,\n        revalidate,\n        expireAt,\n        value.buffer,\n        value.etag\n      )\n    } catch (err) {\n      Log.error(`Failed to write image to cache ${cacheKey}`, err)\n    }\n  }\n}\nexport class ImageError extends Error {\n  statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n\n    // ensure an error status is used > 400\n    if (statusCode >= 400) {\n      this.statusCode = statusCode\n    } else {\n      this.statusCode = 500\n    }\n  }\n}\n\nfunction parseCacheControl(\n  str: string | null | undefined\n): Map<string, string> {\n  const map = new Map<string, string>()\n  if (!str) {\n    return map\n  }\n  for (let directive of str.split(',')) {\n    let [key, value] = directive.trim().split('=', 2)\n    key = key.toLowerCase()\n    if (value) {\n      value = value.toLowerCase()\n    }\n    map.set(key, value)\n  }\n  return map\n}\n\nexport function getMaxAge(str: string | null | undefined): number {\n  const map = parseCacheControl(str)\n  if (map) {\n    let age = map.get('s-maxage') || map.get('max-age') || ''\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1)\n    }\n    const n = parseInt(age, 10)\n    if (!isNaN(n)) {\n      return n\n    }\n  }\n  return 0\n}\n\nexport async function optimizeImage({\n  buffer,\n  contentType,\n  quality,\n  width,\n  height,\n}: {\n  buffer: Buffer\n  contentType: string\n  quality: number\n  width: number\n  height?: number\n}): Promise<Buffer> {\n  const sharp = getSharp()\n  const transformer = sharp(buffer).timeout({ seconds: 7 }).rotate()\n\n  if (height) {\n    transformer.resize(width, height)\n  } else {\n    transformer.resize(width, undefined, {\n      withoutEnlargement: true,\n    })\n  }\n\n  if (contentType === AVIF) {\n    const avifQuality = quality - 20\n    transformer.avif({\n      quality: Math.max(avifQuality, 1),\n    })\n  } else if (contentType === WEBP) {\n    transformer.webp({ quality })\n  } else if (contentType === PNG) {\n    transformer.png({ quality })\n  } else if (contentType === JPEG) {\n    transformer.jpeg({ quality, mozjpeg: true })\n  }\n\n  const optimizedBuffer = await transformer.toBuffer()\n\n  return optimizedBuffer\n}\n\nexport async function fetchExternalImage(href: string): Promise<ImageUpstream> {\n  const res = await fetch(href, {\n    signal: AbortSignal.timeout(7_000),\n  }).catch((err) => err as Error)\n\n  if (res instanceof Error) {\n    const err = res as Error\n    if (err.name === 'TimeoutError') {\n      Log.error('upstream image response timed out for', href)\n      throw new ImageError(\n        504,\n        '\"url\" parameter is valid but upstream response timed out'\n      )\n    }\n    throw err\n  }\n\n  if (!res.ok) {\n    Log.error('upstream image response failed for', href, res.status)\n    throw new ImageError(\n      res.status,\n      '\"url\" parameter is valid but upstream response is invalid'\n    )\n  }\n\n  const buffer = Buffer.from(await res.arrayBuffer())\n  const contentType = res.headers.get('Content-Type')\n  const cacheControl = res.headers.get('Cache-Control')\n\n  return { buffer, contentType, cacheControl }\n}\n\nexport async function fetchInternalImage(\n  href: string,\n  _req: IncomingMessage,\n  _res: ServerResponse,\n  handleRequest: (\n    newReq: IncomingMessage,\n    newRes: ServerResponse,\n    newParsedUrl?: NextUrlWithParsedQuery\n  ) => Promise<void>\n): Promise<ImageUpstream> {\n  try {\n    const mocked = createRequestResponseMocks({\n      url: href,\n      method: _req.method || 'GET',\n      headers: _req.headers,\n      socket: _req.socket,\n    })\n\n    await handleRequest(mocked.req, mocked.res, nodeUrl.parse(href, true))\n    await mocked.res.hasStreamed\n\n    if (!mocked.res.statusCode) {\n      Log.error('image response failed for', href, mocked.res.statusCode)\n      throw new ImageError(\n        mocked.res.statusCode,\n        '\"url\" parameter is valid but internal response is invalid'\n      )\n    }\n\n    const buffer = Buffer.concat(mocked.res.buffers)\n    const contentType = mocked.res.getHeader('Content-Type')\n    const cacheControl = mocked.res.getHeader('Cache-Control')\n    return { buffer, contentType, cacheControl }\n  } catch (err) {\n    Log.error('upstream image response failed for', href, err)\n    throw new ImageError(\n      500,\n      '\"url\" parameter is valid but upstream response is invalid'\n    )\n  }\n}\n\nexport async function imageOptimizer(\n  imageUpstream: ImageUpstream,\n  paramsResult: Pick<\n    ImageParamsResult,\n    'href' | 'width' | 'quality' | 'mimeType'\n  >,\n  nextConfig: {\n    images: Pick<\n      NextConfigComplete['images'],\n      'dangerouslyAllowSVG' | 'minimumCacheTTL'\n    >\n  },\n  isDev: boolean | undefined\n): Promise<{ buffer: Buffer; contentType: string; maxAge: number }> {\n  const { href, quality, width, mimeType } = paramsResult\n  const upstreamBuffer = imageUpstream.buffer\n  const maxAge = getMaxAge(imageUpstream.cacheControl)\n  const upstreamType =\n    detectContentType(upstreamBuffer) ||\n    imageUpstream.contentType?.toLowerCase().trim()\n\n  if (upstreamType) {\n    if (\n      upstreamType.startsWith('image/svg') &&\n      !nextConfig.images.dangerouslyAllowSVG\n    ) {\n      Log.error(\n        `The requested resource \"${href}\" has type \"${upstreamType}\" but dangerouslyAllowSVG is disabled`\n      )\n      throw new ImageError(\n        400,\n        '\"url\" parameter is valid but image type is not allowed'\n      )\n    }\n\n    if (ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)) {\n      Log.warnOnce(\n        `The requested resource \"${href}\" is an animated image so it will not be optimized. Consider adding the \"unoptimized\" property to the <Image>.`\n      )\n      return { buffer: upstreamBuffer, contentType: upstreamType, maxAge }\n    }\n    if (VECTOR_TYPES.includes(upstreamType)) {\n      // We don't warn here because we already know that \"dangerouslyAllowSVG\"\n      // was enabled above, therefore the user explicitly opted in.\n      // If we add more VECTOR_TYPES besides SVG, perhaps we could warn for those.\n      return { buffer: upstreamBuffer, contentType: upstreamType, maxAge }\n    }\n    if (!upstreamType.startsWith('image/') || upstreamType.includes(',')) {\n      Log.error(\n        \"The requested resource isn't a valid image for\",\n        href,\n        'received',\n        upstreamType\n      )\n      throw new ImageError(400, \"The requested resource isn't a valid image.\")\n    }\n  }\n\n  let contentType: string\n\n  if (mimeType) {\n    contentType = mimeType\n  } else if (\n    upstreamType?.startsWith('image/') &&\n    getExtension(upstreamType) &&\n    upstreamType !== WEBP &&\n    upstreamType !== AVIF\n  ) {\n    contentType = upstreamType\n  } else {\n    contentType = JPEG\n  }\n  try {\n    let optimizedBuffer = await optimizeImage({\n      buffer: upstreamBuffer,\n      contentType,\n      quality,\n      width,\n    })\n    if (optimizedBuffer) {\n      if (isDev && width <= BLUR_IMG_SIZE && quality === BLUR_QUALITY) {\n        // During `next dev`, we don't want to generate blur placeholders with webpack\n        // because it can delay starting the dev server. Instead, `next-image-loader.js`\n        // will inline a special url to lazily generate the blur placeholder at request time.\n        const meta = await getImageSize(optimizedBuffer)\n        const opts = {\n          blurWidth: meta.width,\n          blurHeight: meta.height,\n          blurDataURL: `data:${contentType};base64,${optimizedBuffer.toString(\n            'base64'\n          )}`,\n        }\n        optimizedBuffer = Buffer.from(unescape(getImageBlurSvg(opts)))\n        contentType = 'image/svg+xml'\n      }\n      return {\n        buffer: optimizedBuffer,\n        contentType,\n        maxAge: Math.max(maxAge, nextConfig.images.minimumCacheTTL),\n      }\n    } else {\n      throw new ImageError(500, 'Unable to optimize buffer')\n    }\n  } catch (error) {\n    if (upstreamBuffer && upstreamType) {\n      // If we fail to optimize, fallback to the original image\n      return {\n        buffer: upstreamBuffer,\n        contentType: upstreamType,\n        maxAge: nextConfig.images.minimumCacheTTL,\n      }\n    } else {\n      throw new ImageError(\n        400,\n        'Unable to optimize image and unable to fallback to upstream image'\n      )\n    }\n  }\n}\n\nfunction getFileNameWithExtension(\n  url: string,\n  contentType: string | null\n): string {\n  const [urlWithoutQueryParams] = url.split('?', 1)\n  const fileNameWithExtension = urlWithoutQueryParams.split('/').pop()\n  if (!contentType || !fileNameWithExtension) {\n    return 'image.bin'\n  }\n\n  const [fileName] = fileNameWithExtension.split('.', 1)\n  const extension = getExtension(contentType)\n  return `${fileName}.${extension}`\n}\n\nfunction setResponseHeaders(\n  req: IncomingMessage,\n  res: ServerResponse,\n  url: string,\n  etag: string,\n  contentType: string | null,\n  isStatic: boolean,\n  xCache: XCacheHeader,\n  imagesConfig: ImageConfigComplete,\n  maxAge: number,\n  isDev: boolean\n) {\n  res.setHeader('Vary', 'Accept')\n  res.setHeader(\n    'Cache-Control',\n    isStatic\n      ? 'public, max-age=315360000, immutable'\n      : `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`\n  )\n  if (sendEtagResponse(req, res, etag)) {\n    // already called res.end() so we're finished\n    return { finished: true }\n  }\n  if (contentType) {\n    res.setHeader('Content-Type', contentType)\n  }\n\n  const fileName = getFileNameWithExtension(url, contentType)\n  res.setHeader(\n    'Content-Disposition',\n    contentDisposition(fileName, { type: imagesConfig.contentDispositionType })\n  )\n\n  res.setHeader('Content-Security-Policy', imagesConfig.contentSecurityPolicy)\n  res.setHeader('X-Nextjs-Cache', xCache)\n\n  return { finished: false }\n}\n\nexport function sendResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  url: string,\n  extension: string,\n  buffer: Buffer,\n  isStatic: boolean,\n  xCache: XCacheHeader,\n  imagesConfig: ImageConfigComplete,\n  maxAge: number,\n  isDev: boolean\n) {\n  const contentType = getContentType(extension)\n  const etag = getHash([buffer])\n  const result = setResponseHeaders(\n    req,\n    res,\n    url,\n    etag,\n    contentType,\n    isStatic,\n    xCache,\n    imagesConfig,\n    maxAge,\n    isDev\n  )\n  if (!result.finished) {\n    res.setHeader('Content-Length', Buffer.byteLength(buffer))\n    res.end(buffer)\n  }\n}\n\nexport async function getImageSize(buffer: Buffer): Promise<{\n  width?: number\n  height?: number\n}> {\n  const { width, height } = imageSizeOf(buffer)\n  return { width, height }\n}\n"],"names":["ImageError","ImageOptimizerCache","detectContentType","fetchExternalImage","fetchInternalImage","getHash","getImageSize","getMaxAge","imageOptimizer","optimizeImage","sendResponse","AVIF","WEBP","PNG","JPEG","GIF","SVG","ICO","TIFF","BMP","CACHE_VERSION","ANIMATABLE_TYPES","VECTOR_TYPES","BLUR_IMG_SIZE","BLUR_QUALITY","_sharp","getSharp","require","concurrency","divisor","process","env","NODE_ENV","Math","floor","max","e","isError","code","Error","getSupportedMimeType","options","accept","mimeType","mediaType","includes","items","hash","createHash","item","update","String","digest","replace","writeToCacheDir","dir","extension","maxAge","expireAt","buffer","etag","filename","join","promises","rm","recursive","force","catch","mkdir","writeFile","every","b","i","validateParams","req","query","nextConfig","isDev","imageData","images","deviceSizes","imageSizes","domains","minimumCacheTTL","formats","remotePatterns","url","w","q","href","length","Log","warnOnce","errorMessage","Array","isArray","startsWith","isAbsolute","hrefParsed","URL","toString","_error","protocol","hasMatch","test","width","parseInt","isNaN","sizes","push","isValidSize","quality","headers","isStatic","basePath","getCacheKey","constructor","distDir","cacheDir","get","cacheKey","files","readdir","now","Date","file","maxAgeSt","expireAtSt","split","readFile","Number","value","kind","revalidateAfter","curRevalidate","isStale","_","set","revalidate","err","error","statusCode","message","parseCacheControl","str","map","Map","directive","key","trim","toLowerCase","age","endsWith","slice","n","contentType","height","sharp","transformer","timeout","seconds","rotate","resize","undefined","withoutEnlargement","avifQuality","avif","webp","png","jpeg","mozjpeg","optimizedBuffer","toBuffer","res","fetch","signal","AbortSignal","name","ok","status","Buffer","from","arrayBuffer","cacheControl","_req","_res","handleRequest","mocked","createRequestResponseMocks","method","socket","nodeUrl","parse","hasStreamed","concat","buffers","getHeader","imageUpstream","paramsResult","upstreamBuffer","upstreamType","dangerouslyAllowSVG","isAnimated","getExtension","meta","opts","blurWidth","blurHeight","blurDataURL","unescape","getImageBlurSvg","getFileNameWithExtension","urlWithoutQueryParams","fileNameWithExtension","pop","fileName","setResponseHeaders","xCache","imagesConfig","setHeader","sendEtagResponse","finished","contentDisposition","type","contentDispositionType","contentSecurityPolicy","getContentType","result","byteLength","end","imageSizeOf"],"mappings":"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"}