{"version":3,"sources":["../../../src/server/async-storage/with-static-generation-store.ts"],"sourcesContent":["import type { WithStore } from './with-store'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOptsPartial } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\n\nimport { createPrerenderState } from '../app-render/dynamic-rendering'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type StaticGenerationContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  requestEndedState?: { ended?: boolean }\n  renderOpts: {\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: StaticGenerationStore['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOptsPartial['experimental'],\n      'isRoutePPREnabled' | 'after'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: StaticGenerationStore\n  } & Pick<\n    // Pull some properties from RenderOptsPartial so that the docs are also\n    // mirrored.\n    RenderOptsPartial,\n    | 'supportsDynamicResponse'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n  > &\n    Partial<RequestLifecycleOpts>\n}\n\nexport const withStaticGenerationStore: WithStore<\n  StaticGenerationStore,\n  StaticGenerationContext\n> = <Result>(\n  storage: AsyncLocalStorage<StaticGenerationStore>,\n  { page, renderOpts, requestEndedState }: StaticGenerationContext,\n  callback: (store: StaticGenerationStore) => Result\n): Result => {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const prerenderState: StaticGenerationStore['prerenderState'] =\n    isStaticGeneration && renderOpts.experimental?.isRoutePPREnabled\n      ? createPrerenderState(renderOpts.isDebugDynamicAccesses)\n      : null\n\n  const store: StaticGenerationStore = {\n    isStaticGeneration,\n    page,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    prerenderState,\n    requestEndedState,\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return storage.run(store, callback, store)\n}\n"],"names":["withStaticGenerationStore","storage","page","renderOpts","requestEndedState","callback","isStaticGeneration","supportsDynamicResponse","isDraftMode","isServerAction","prerenderState","experimental","isRoutePPREnabled","createPrerenderState","isDebugDynamicAccesses","store","route","normalizeAppPath","incrementalCache","globalThis","__incrementalCache","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","run"],"mappings":";;;;+BAwDaA;;;eAAAA;;;kCAhDwB;0BACJ;AA+C1B,MAAMA,4BAGT,CACFC,SACA,EAAEC,IAAI,EAAEC,UAAU,EAAEC,iBAAiB,EAA2B,EAChEC;QAyBwBF;IAvBxB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMG,qBACJ,CAACH,WAAWI,uBAAuB,IACnC,CAACJ,WAAWK,WAAW,IACvB,CAACL,WAAWM,cAAc;IAE5B,MAAMC,iBACJJ,wBAAsBH,2BAAAA,WAAWQ,YAAY,qBAAvBR,yBAAyBS,iBAAiB,IAC5DC,IAAAA,sCAAoB,EAACV,WAAWW,sBAAsB,IACtD;IAEN,MAAMC,QAA+B;QACnCT;QACAJ;QACAc,OAAOC,IAAAA,0BAAgB,EAACf;QACxBgB,kBACE,qEAAqE;QACrE,mDAAmD;QACnDf,WAAWe,gBAAgB,IAAI,AAACC,WAAmBC,kBAAkB;QACvEC,cAAclB,WAAWkB,YAAY;QACrCC,gBAAgBnB,WAAWoB,UAAU;QACrCC,YAAYrB,WAAWqB,UAAU;QACjCC,sBAAsBtB,WAAWsB,oBAAoB;QAErDjB,aAAaL,WAAWK,WAAW;QAEnCE;QACAN;IACF;IAEA,sFAAsF;IACtFD,WAAWY,KAAK,GAAGA;IAEnB,OAAOd,QAAQyB,GAAG,CAACX,OAAOV,UAAUU;AACtC"}