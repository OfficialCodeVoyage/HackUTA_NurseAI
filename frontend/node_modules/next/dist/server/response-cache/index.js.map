{"version":3,"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  IncrementalCache,\n  ResponseCacheEntry,\n  ResponseGenerator,\n  IncrementalCacheItem,\n  ResponseCacheBase,\n  IncrementalCacheKindHint,\n} from './types'\nimport { RouteKind } from '../route-kind'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { fromResponseCacheEntry, toResponseCacheEntry } from './utils'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalCacheItem | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalCacheItem | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind?: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) return responseGenerator(false, null)\n\n    const { incrementalCache, isOnDemandRevalidate = false } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        let kindHint: IncrementalCacheKindHint | undefined\n        if (\n          context.routeKind === RouteKind.APP_PAGE ||\n          context.routeKind === RouteKind.APP_ROUTE\n        ) {\n          kindHint = 'app'\n        } else if (context.routeKind === RouteKind.PAGES) {\n          kindHint = 'pages'\n        }\n\n        let resolved = false\n        let cachedResponse: IncrementalCacheItem = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kindHint,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            if (cachedResponse.value?.kind === 'FETCH') {\n              throw new Error(\n                `invariant: unexpected cachedResponse of kind fetch in response cache`\n              )\n            }\n\n            resolve({\n              ...cachedResponse,\n              revalidate: cachedResponse.curRevalidate,\n            })\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator(\n            resolved,\n            cachedResponse,\n            true\n          )\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          if (typeof resolveValue.revalidate !== 'undefined') {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                revalidate: resolveValue.revalidate,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a getStaticProps path is erroring we automatically re-set the\n          // existing cache under a new expiration to prevent non-stop retrying.\n          if (cachedResponse) {\n            await incrementalCache.set(key, cachedResponse.value, {\n              revalidate: Math.min(\n                Math.max(cachedResponse.revalidate || 3, 3),\n                30\n              ),\n              isRoutePPREnabled: context.isRoutePPREnabled,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["ResponseCache","constructor","minimalMode","batcher","Batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","scheduleOnNextTick","minimalModeKey","get","responseGenerator","context","incrementalCache","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kindHint","routeKind","RouteKind","APP_PAGE","APP_ROUTE","PAGES","resolved","cachedResponse","isRoutePPREnabled","value","kind","Error","revalidate","curRevalidate","isStale","isPrefetch","cacheEntry","undefined","resolveValue","fromResponseCacheEntry","isMiss","set","err","Math","min","max","console","error","toResponseCacheEntry"],"mappings":";;;;+BAgBA;;;eAAqBA;;;;2BARK;yBAEF;2BACW;uBAC0B;qBAE/C;;;;;;;;;;;;;;AAEC,MAAMA;IAwBnBC,YAAYC,WAAoB,CAAE;aAvBjBC,UAAUC,gBAAO,CAACC,MAAM,CAIvC;YACA,0EAA0E;YAC1E,4EAA4E;YAC5EC,YAAY,CAAC,EAAEC,GAAG,EAAEC,oBAAoB,EAAE,GACxC,CAAC,EAAED,IAAI,CAAC,EAAEC,uBAAuB,MAAM,IAAI,CAAC;YAC9C,sEAAsE;YACtE,uEAAuE;YACvE,oDAAoD;YACpDC,aAAaC,6BAAkB;QACjC;QAWE,4EAA4E;QAC5E,qEAAqE;QACrE,MAAMC,iBAAiB;QACvB,IAAI,CAACA,eAAe,GAAGT;IACzB;IAEA,MAAaU,IACXL,GAAkB,EAClBM,iBAAoC,EACpCC,OAMC,EACmC;QACpC,0EAA0E;QAC1E,6DAA6D;QAC7D,IAAI,CAACP,KAAK,OAAOM,kBAAkB,OAAO;QAE1C,MAAM,EAAEE,gBAAgB,EAAEP,uBAAuB,KAAK,EAAE,GAAGM;QAE3D,MAAME,WAAW,MAAM,IAAI,CAACb,OAAO,CAACc,KAAK,CACvC;YAAEV;YAAKC;QAAqB,GAC5B,OAAOU,UAAUC;gBAKb;YAJF,+DAA+D;YAC/D,iDAAiD;YACjD,IACE,IAAI,CAACjB,WAAW,IAChB,EAAA,0BAAA,IAAI,CAACkB,iBAAiB,qBAAtB,wBAAwBb,GAAG,MAAKW,YAChC,IAAI,CAACE,iBAAiB,CAACC,SAAS,GAAGC,KAAKC,GAAG,IAC3C;gBACA,OAAO,IAAI,CAACH,iBAAiB,CAACI,KAAK;YACrC;YAEA,mEAAmE;YACnE,IAAIC;YACJ,IACEX,QAAQY,SAAS,KAAKC,oBAAS,CAACC,QAAQ,IACxCd,QAAQY,SAAS,KAAKC,oBAAS,CAACE,SAAS,EACzC;gBACAJ,WAAW;YACb,OAAO,IAAIX,QAAQY,SAAS,KAAKC,oBAAS,CAACG,KAAK,EAAE;gBAChDL,WAAW;YACb;YAEA,IAAIM,WAAW;YACf,IAAIC,iBAAuC;YAC3C,IAAI;gBACFA,iBAAiB,CAAC,IAAI,CAAC9B,WAAW,GAC9B,MAAMa,iBAAiBH,GAAG,CAACL,KAAK;oBAC9BkB;oBACAQ,mBAAmBnB,QAAQmB,iBAAiB;gBAC9C,KACA;gBAEJ,IAAID,kBAAkB,CAACxB,sBAAsB;wBACvCwB;oBAAJ,IAAIA,EAAAA,wBAAAA,eAAeE,KAAK,qBAApBF,sBAAsBG,IAAI,MAAK,SAAS;wBAC1C,MAAM,IAAIC,MACR,CAAC,oEAAoE,CAAC;oBAE1E;oBAEAjB,QAAQ;wBACN,GAAGa,cAAc;wBACjBK,YAAYL,eAAeM,aAAa;oBAC1C;oBACAP,WAAW;oBAEX,IAAI,CAACC,eAAeO,OAAO,IAAIzB,QAAQ0B,UAAU,EAAE;wBACjD,oDAAoD;wBACpD,oBAAoB;wBACpB,OAAO;oBACT;gBACF;gBAEA,MAAMC,aAAa,MAAM5B,kBACvBkB,UACAC,gBACA;gBAGF,mEAAmE;gBACnE,cAAc;gBACd,IAAI,CAACS,YAAY;oBACf,+CAA+C;oBAC/C,IAAI,IAAI,CAACvC,WAAW,EAAE,IAAI,CAACkB,iBAAiB,GAAGsB;oBAC/C,OAAO;gBACT;gBAEA,MAAMC,eAAe,MAAMC,IAAAA,6BAAsB,EAAC;oBAChD,GAAGH,UAAU;oBACbI,QAAQ,CAACb;gBACX;gBACA,IAAI,CAACW,cAAc;oBACjB,+CAA+C;oBAC/C,IAAI,IAAI,CAACzC,WAAW,EAAE,IAAI,CAACkB,iBAAiB,GAAGsB;oBAC/C,OAAO;gBACT;gBAEA,+DAA+D;gBAC/D,yBAAyB;gBACzB,IAAI,CAAClC,wBAAwB,CAACuB,UAAU;oBACtCZ,QAAQwB;oBACRZ,WAAW;gBACb;gBAEA,IAAI,OAAOY,aAAaN,UAAU,KAAK,aAAa;oBAClD,IAAI,IAAI,CAACnC,WAAW,EAAE;wBACpB,IAAI,CAACkB,iBAAiB,GAAG;4BACvBb,KAAKW;4BACLM,OAAOmB;4BACPtB,WAAWC,KAAKC,GAAG,KAAK;wBAC1B;oBACF,OAAO;wBACL,MAAMR,iBAAiB+B,GAAG,CAACvC,KAAKoC,aAAaT,KAAK,EAAE;4BAClDG,YAAYM,aAAaN,UAAU;4BACnCJ,mBAAmBnB,QAAQmB,iBAAiB;wBAC9C;oBACF;gBACF;gBAEA,OAAOU;YACT,EAAE,OAAOI,KAAK;gBACZ,qEAAqE;gBACrE,sEAAsE;gBACtE,IAAIf,gBAAgB;oBAClB,MAAMjB,iBAAiB+B,GAAG,CAACvC,KAAKyB,eAAeE,KAAK,EAAE;wBACpDG,YAAYW,KAAKC,GAAG,CAClBD,KAAKE,GAAG,CAAClB,eAAeK,UAAU,IAAI,GAAG,IACzC;wBAEFJ,mBAAmBnB,QAAQmB,iBAAiB;oBAC9C;gBACF;gBAEA,qEAAqE;gBACrE,kDAAkD;gBAClD,IAAIF,UAAU;oBACZoB,QAAQC,KAAK,CAACL;oBACd,OAAO;gBACT;gBAEA,gEAAgE;gBAChE,MAAMA;YACR;QACF;QAGF,OAAOM,IAAAA,2BAAoB,EAACrC;IAC9B;AACF"}