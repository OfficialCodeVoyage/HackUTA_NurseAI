{"version":3,"sources":["../../../src/build/flying-shuttle/store-shuttle.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport {\n  BUILD_MANIFEST,\n  APP_BUILD_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  APP_PATH_ROUTES_MANIFEST,\n  PAGES_MANIFEST,\n  ROUTES_MANIFEST,\n} from '../../shared/lib/constants'\nimport { recursiveCopy } from '../../lib/recursive-copy'\n\n// we can create a new shuttle with the outputs before env values have\n// been inlined, can be done after stitching takes place\nexport async function storeShuttle({\n  distDir,\n  shuttleDir,\n}: {\n  distDir: string\n  shuttleDir: string\n}) {\n  await fs.promises.rm(shuttleDir, { force: true, recursive: true })\n  await fs.promises.mkdir(shuttleDir, { recursive: true })\n\n  // copy all server entries\n  await recursiveCopy(\n    path.join(distDir, 'server'),\n    path.join(shuttleDir, 'server'),\n    {\n      filter(item) {\n        return !item.match(/\\.(rsc|meta|html)$/)\n      },\n    }\n  )\n\n  const pagesManifest = JSON.parse(\n    await fs.promises.readFile(\n      path.join(shuttleDir, 'server', PAGES_MANIFEST),\n      'utf8'\n    )\n  )\n  // ensure manifest isn't modified to .html as it's before static gen\n  for (const key of Object.keys(pagesManifest)) {\n    pagesManifest[key] = pagesManifest[key].replace(/\\.html$/, '.js')\n  }\n  await fs.promises.writeFile(\n    path.join(shuttleDir, 'server', PAGES_MANIFEST),\n    JSON.stringify(pagesManifest)\n  )\n\n  // copy static assets\n  await recursiveCopy(\n    path.join(distDir, 'static'),\n    path.join(shuttleDir, 'static')\n  )\n\n  // copy manifests not nested in {distDir}/server/\n  await fs.promises.mkdir(path.join(shuttleDir, 'manifests'), {\n    recursive: true,\n  })\n\n  for (const item of [\n    BUILD_MANIFEST,\n    ROUTES_MANIFEST,\n    APP_BUILD_MANIFEST,\n    REACT_LOADABLE_MANIFEST,\n    APP_PATH_ROUTES_MANIFEST,\n  ]) {\n    const outputPath = path.join(shuttleDir, 'manifests', item)\n    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true })\n    await fs.promises.copyFile(path.join(distDir, item), outputPath)\n  }\n}\n"],"names":["storeShuttle","distDir","shuttleDir","fs","promises","rm","force","recursive","mkdir","recursiveCopy","path","join","filter","item","match","pagesManifest","JSON","parse","readFile","PAGES_MANIFEST","key","Object","keys","replace","writeFile","stringify","BUILD_MANIFEST","ROUTES_MANIFEST","APP_BUILD_MANIFEST","REACT_LOADABLE_MANIFEST","APP_PATH_ROUTES_MANIFEST","outputPath","dirname","copyFile"],"mappings":";;;;+BAcsBA;;;eAAAA;;;2DAdP;6DACE;2BAQV;+BACuB;;;;;;AAIvB,eAAeA,aAAa,EACjCC,OAAO,EACPC,UAAU,EAIX;IACC,MAAMC,WAAE,CAACC,QAAQ,CAACC,EAAE,CAACH,YAAY;QAAEI,OAAO;QAAMC,WAAW;IAAK;IAChE,MAAMJ,WAAE,CAACC,QAAQ,CAACI,KAAK,CAACN,YAAY;QAAEK,WAAW;IAAK;IAEtD,0BAA0B;IAC1B,MAAME,IAAAA,4BAAa,EACjBC,aAAI,CAACC,IAAI,CAACV,SAAS,WACnBS,aAAI,CAACC,IAAI,CAACT,YAAY,WACtB;QACEU,QAAOC,IAAI;YACT,OAAO,CAACA,KAAKC,KAAK,CAAC;QACrB;IACF;IAGF,MAAMC,gBAAgBC,KAAKC,KAAK,CAC9B,MAAMd,WAAE,CAACC,QAAQ,CAACc,QAAQ,CACxBR,aAAI,CAACC,IAAI,CAACT,YAAY,UAAUiB,yBAAc,GAC9C;IAGJ,oEAAoE;IACpE,KAAK,MAAMC,OAAOC,OAAOC,IAAI,CAACP,eAAgB;QAC5CA,aAAa,CAACK,IAAI,GAAGL,aAAa,CAACK,IAAI,CAACG,OAAO,CAAC,WAAW;IAC7D;IACA,MAAMpB,WAAE,CAACC,QAAQ,CAACoB,SAAS,CACzBd,aAAI,CAACC,IAAI,CAACT,YAAY,UAAUiB,yBAAc,GAC9CH,KAAKS,SAAS,CAACV;IAGjB,qBAAqB;IACrB,MAAMN,IAAAA,4BAAa,EACjBC,aAAI,CAACC,IAAI,CAACV,SAAS,WACnBS,aAAI,CAACC,IAAI,CAACT,YAAY;IAGxB,iDAAiD;IACjD,MAAMC,WAAE,CAACC,QAAQ,CAACI,KAAK,CAACE,aAAI,CAACC,IAAI,CAACT,YAAY,cAAc;QAC1DK,WAAW;IACb;IAEA,KAAK,MAAMM,QAAQ;QACjBa,yBAAc;QACdC,0BAAe;QACfC,6BAAkB;QAClBC,kCAAuB;QACvBC,mCAAwB;KACzB,CAAE;QACD,MAAMC,aAAarB,aAAI,CAACC,IAAI,CAACT,YAAY,aAAaW;QACtD,MAAMV,WAAE,CAACC,QAAQ,CAACI,KAAK,CAACE,aAAI,CAACsB,OAAO,CAACD,aAAa;YAAExB,WAAW;QAAK;QACpE,MAAMJ,WAAE,CAACC,QAAQ,CAAC6B,QAAQ,CAACvB,aAAI,CAACC,IAAI,CAACV,SAASY,OAAOkB;IACvD;AACF"}