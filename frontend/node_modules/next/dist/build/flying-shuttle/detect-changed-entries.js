"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    detectChangedEntries: null,
    hasShuttle: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    detectChangedEntries: function() {
        return detectChangedEntries;
    },
    hasShuttle: function() {
        return hasShuttle;
    }
});
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _crypto = /*#__PURE__*/ _interop_require_default(require("crypto"));
const _entries = require("../entries");
const _asyncsema = require("next/dist/compiled/async-sema");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let _hasShuttle = undefined;
async function hasShuttle(shuttleDir) {
    if (typeof _hasShuttle === 'boolean') {
        return _hasShuttle;
    }
    _hasShuttle = await _fs.default.promises.access(_path.default.join(shuttleDir, 'server')).then(()=>true).catch(()=>false);
    return _hasShuttle;
}
async function detectChangedEntries({ appPaths, pagesPaths, pageExtensions, distDir, shuttleDir }) {
    const changedEntries = {
        app: [],
        pages: []
    };
    const unchangedEntries = {
        app: [],
        pages: []
    };
    if (!await hasShuttle(shuttleDir)) {
        // no shuttle so consider everything changed
        console.log(`no shuttle. can't detect changes`);
        return {
            changed: {
                pages: pagesPaths || [],
                app: appPaths || []
            },
            unchanged: {
                pages: [],
                app: []
            }
        };
    }
    const hashCache = new Map();
    async function computeHash(p) {
        let hash = hashCache.get(p);
        if (hash) {
            return hash;
        }
        return new Promise((resolve, reject)=>{
            const hashInst = _crypto.default.createHash('sha1');
            const stream = _fs.default.createReadStream(p);
            stream.on('error', (err)=>reject(err));
            stream.on('data', (chunk)=>hashInst.update(chunk));
            stream.on('end', ()=>{
                const digest = hashInst.digest('hex');
                resolve(digest);
                hashCache.set(p, digest);
            });
        });
    }
    const hashSema = new _asyncsema.Sema(16);
    let globalEntryChanged = false;
    async function detectChange({ normalizedEntry, entry, type }) {
        const traceFile = _path.default.join(shuttleDir, 'server', type, `${normalizedEntry}.js.nft.json`);
        let changed = true;
        // we don't need to check any further entry's dependencies if
        // a global entry changed since that invalidates everything
        if (!globalEntryChanged) {
            try {
                const traceData = JSON.parse(await _fs.default.promises.readFile(traceFile, 'utf8'));
                if (traceData) {
                    let changedDependency = false;
                    await Promise.all(Object.keys(traceData.fileHashes).map(async (file)=>{
                        try {
                            if (changedDependency) return;
                            await hashSema.acquire();
                            const relativeTraceFile = _path.default.relative(_path.default.join(shuttleDir, 'server', type), traceFile);
                            const originalTraceFile = _path.default.join(distDir, 'server', type, relativeTraceFile);
                            const absoluteFile = _path.default.join(_path.default.dirname(originalTraceFile), file);
                            if (absoluteFile.startsWith(distDir)) {
                                return;
                            }
                            const prevHash = traceData.fileHashes[file];
                            const curHash = await computeHash(absoluteFile);
                            if (prevHash !== curHash) {
                                console.log('detected change on', {
                                    prevHash,
                                    curHash,
                                    file,
                                    entry: normalizedEntry
                                });
                                changedDependency = true;
                            }
                        } finally{
                            hashSema.release();
                        }
                    }));
                    if (!changedDependency) {
                        changed = false;
                    }
                } else {
                    console.error('missing trace data', traceFile, normalizedEntry);
                }
            } catch (err) {
                console.error(`Failed to detect change for ${entry}`, err);
            }
        }
        // we always rebuild global entries so we have a version
        // that matches the newest build/runtime
        const isGlobalEntry = /(_app|_document|_error)/.test(entry);
        if (changed || isGlobalEntry) {
            // if a global entry changed all entries are changed
            if (!globalEntryChanged && isGlobalEntry) {
                console.log(`global entry ${entry} changed invalidating all entries`);
                globalEntryChanged = true;
                // move unchanged to changed
                changedEntries[type].push(...unchangedEntries[type]);
            }
            changedEntries[type].push(entry);
        } else {
            unchangedEntries[type].push(entry);
        }
    }
    // loop over entries and their dependency's hashes
    // to detect which changed
    for (const entry of pagesPaths || []){
        let normalizedEntry = (0, _entries.getPageFromPath)(entry, pageExtensions);
        if (normalizedEntry === '/') {
            normalizedEntry = '/index';
        }
        await detectChange({
            entry,
            normalizedEntry,
            type: 'pages'
        });
    }
    for (const entry of appPaths || []){
        const normalizedEntry = (0, _entries.getPageFromPath)(entry, pageExtensions);
        await detectChange({
            entry,
            normalizedEntry,
            type: 'app'
        });
    }
    console.log('changed entries', JSON.stringify({
        changedEntries,
        unchangedEntries
    }, null, 2));
    return {
        changed: changedEntries,
        unchanged: unchangedEntries
    };
}

//# sourceMappingURL=detect-changed-entries.js.map