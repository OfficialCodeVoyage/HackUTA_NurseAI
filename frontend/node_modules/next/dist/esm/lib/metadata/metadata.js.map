{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type {\n  AppRenderContext,\n  GetDynamicParamFromSegment,\n} from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n  FacebookMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport {\n  createDefaultMetadata,\n  createDefaultViewport,\n} from './default-metadata'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport type { MetadataContext } from './types/resolvers'\n\nexport function createMetadataContext(\n  pathname: string,\n  renderOpts: AppRenderContext['renderOpts']\n): MetadataContext {\n  return {\n    pathname,\n    trailingSlash: renderOpts.trailingSlash,\n    isStandaloneMode: renderOpts.nextConfigOutput === 'standalone',\n  }\n}\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  query,\n  metadataContext,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n}: {\n  tree: LoaderTree\n  query: ParsedUrlQuery\n  metadataContext: MetadataContext\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, React.ComponentType] {\n  let resolve: (value: Error | undefined) => void | undefined\n  // Only use promise.resolve here to avoid unhandled rejections\n  const metadataErrorResolving = new Promise<Error | undefined>((res) => {\n    resolve = res\n  })\n\n  async function MetadataTree() {\n    const defaultMetadata = createDefaultMetadata()\n    const defaultViewport = createDefaultViewport()\n    let metadata: ResolvedMetadata | undefined = defaultMetadata\n    let viewport: ResolvedViewport | undefined = defaultViewport\n    let error: any\n    const errorMetadataItem: [null, null, null] = [null, null, null]\n    const errorConvention = errorType === 'redirect' ? undefined : errorType\n    const searchParams = createDynamicallyTrackedSearchParams(query)\n\n    const [resolvedError, resolvedMetadata, resolvedViewport] =\n      await resolveMetadata({\n        tree,\n        parentParams: {},\n        metadataItems: [],\n        errorMetadataItem,\n        searchParams,\n        getDynamicParamFromSegment,\n        errorConvention,\n        metadataContext,\n      })\n    if (!resolvedError) {\n      viewport = resolvedViewport\n      metadata = resolvedMetadata\n      resolve(undefined)\n    } else {\n      error = resolvedError\n      // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n      // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n      // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n      // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n      if (!errorType && isNotFoundError(resolvedError)) {\n        const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n          await resolveMetadata({\n            tree,\n            parentParams: {},\n            metadataItems: [],\n            errorMetadataItem,\n            searchParams,\n            getDynamicParamFromSegment,\n            errorConvention: 'not-found',\n            metadataContext,\n          })\n        viewport = notFoundViewport\n        metadata = notFoundMetadata\n        error = notFoundMetadataError || error\n      }\n      resolve(error)\n    }\n\n    const elements = MetaFilter([\n      ViewportMeta({ viewport: viewport }),\n      BasicMeta({ metadata }),\n      AlternatesMetadata({ alternates: metadata.alternates }),\n      ItunesMeta({ itunes: metadata.itunes }),\n      FacebookMeta({ facebook: metadata.facebook }),\n      FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n      VerificationMeta({ verification: metadata.verification }),\n      AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n      OpenGraphMetadata({ openGraph: metadata.openGraph }),\n      TwitterMetadata({ twitter: metadata.twitter }),\n      AppLinksMeta({ appLinks: metadata.appLinks }),\n      IconsMetadata({ icons: metadata.icons }),\n    ])\n\n    if (appUsingSizeAdjustment) elements.push(<meta name=\"next-size-adjust\" />)\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n      </>\n    )\n  }\n\n  async function MetadataOutlet() {\n    const error = await metadataErrorResolving\n    if (error) {\n      throw error\n    }\n    return null\n  }\n\n  return [MetadataTree, MetadataOutlet]\n}\n"],"names":["React","AppleWebAppMeta","FormatDetectionMeta","ItunesMeta","BasicMeta","ViewportMeta","VerificationMeta","FacebookMeta","AlternatesMetadata","OpenGraphMetadata","TwitterMetadata","AppLinksMeta","IconsMetadata","resolveMetadata","MetaFilter","createDefaultMetadata","createDefaultViewport","isNotFoundError","createMetadataContext","pathname","renderOpts","trailingSlash","isStandaloneMode","nextConfigOutput","createMetadataComponents","tree","query","metadataContext","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","resolve","metadataErrorResolving","Promise","res","MetadataTree","defaultMetadata","defaultViewport","metadata","viewport","error","errorMetadataItem","errorConvention","undefined","searchParams","resolvedError","resolvedMetadata","resolvedViewport","parentParams","metadataItems","notFoundMetadataError","notFoundMetadata","notFoundViewport","elements","alternates","itunes","facebook","formatDetection","verification","appleWebApp","openGraph","twitter","appLinks","icons","push","meta","name","map","el","index","cloneElement","key","MetadataOutlet"],"mappings":";AAOA,OAAOA,WAAW,QAAO;AACzB,SACEC,eAAe,EACfC,mBAAmB,EACnBC,UAAU,EACVC,SAAS,EACTC,YAAY,EACZC,gBAAgB,EAChBC,YAAY,QACP,mBAAkB;AACzB,SAASC,kBAAkB,QAAQ,uBAAsB;AACzD,SACEC,iBAAiB,EACjBC,eAAe,EACfC,YAAY,QACP,uBAAsB;AAC7B,SAASC,aAAa,QAAQ,mBAAkB;AAChD,SAASC,eAAe,QAAQ,qBAAoB;AACpD,SAASC,UAAU,QAAQ,kBAAiB;AAK5C,SACEC,qBAAqB,EACrBC,qBAAqB,QAChB,qBAAoB;AAC3B,SAASC,eAAe,QAAQ,oCAAmC;AAGnE,OAAO,SAASC,sBACdC,QAAgB,EAChBC,UAA0C;IAE1C,OAAO;QACLD;QACAE,eAAeD,WAAWC,aAAa;QACvCC,kBAAkBF,WAAWG,gBAAgB,KAAK;IACpD;AACF;AAEA,+DAA+D;AAC/D,+DAA+D;AAC/D,sGAAsG;AACtG,0GAA0G;AAC1G,uEAAuE;AACvE,4EAA4E;AAC5E,OAAO,SAASC,yBAAyB,EACvCC,IAAI,EACJC,KAAK,EACLC,eAAe,EACfC,0BAA0B,EAC1BC,sBAAsB,EACtBC,SAAS,EACTC,oCAAoC,EAWrC;IACC,IAAIC;IACJ,8DAA8D;IAC9D,MAAMC,yBAAyB,IAAIC,QAA2B,CAACC;QAC7DH,UAAUG;IACZ;IAEA,eAAeC;QACb,MAAMC,kBAAkBtB;QACxB,MAAMuB,kBAAkBtB;QACxB,IAAIuB,WAAyCF;QAC7C,IAAIG,WAAyCF;QAC7C,IAAIG;QACJ,MAAMC,oBAAwC;YAAC;YAAM;YAAM;SAAK;QAChE,MAAMC,kBAAkBb,cAAc,aAAac,YAAYd;QAC/D,MAAMe,eAAed,qCAAqCL;QAE1D,MAAM,CAACoB,eAAeC,kBAAkBC,iBAAiB,GACvD,MAAMnC,gBAAgB;YACpBY;YACAwB,cAAc,CAAC;YACfC,eAAe,EAAE;YACjBR;YACAG;YACAjB;YACAe;YACAhB;QACF;QACF,IAAI,CAACmB,eAAe;YAClBN,WAAWQ;YACXT,WAAWQ;YACXf,QAAQY;QACV,OAAO;YACLH,QAAQK;YACR,gGAAgG;YAChG,sGAAsG;YACtG,0FAA0F;YAC1F,+FAA+F;YAC/F,IAAI,CAAChB,aAAab,gBAAgB6B,gBAAgB;gBAChD,MAAM,CAACK,uBAAuBC,kBAAkBC,iBAAiB,GAC/D,MAAMxC,gBAAgB;oBACpBY;oBACAwB,cAAc,CAAC;oBACfC,eAAe,EAAE;oBACjBR;oBACAG;oBACAjB;oBACAe,iBAAiB;oBACjBhB;gBACF;gBACFa,WAAWa;gBACXd,WAAWa;gBACXX,QAAQU,yBAAyBV;YACnC;YACAT,QAAQS;QACV;QAEA,MAAMa,WAAWxC,WAAW;YAC1BT,aAAa;gBAAEmC,UAAUA;YAAS;YAClCpC,UAAU;gBAAEmC;YAAS;YACrB/B,mBAAmB;gBAAE+C,YAAYhB,SAASgB,UAAU;YAAC;YACrDpD,WAAW;gBAAEqD,QAAQjB,SAASiB,MAAM;YAAC;YACrCjD,aAAa;gBAAEkD,UAAUlB,SAASkB,QAAQ;YAAC;YAC3CvD,oBAAoB;gBAAEwD,iBAAiBnB,SAASmB,eAAe;YAAC;YAChEpD,iBAAiB;gBAAEqD,cAAcpB,SAASoB,YAAY;YAAC;YACvD1D,gBAAgB;gBAAE2D,aAAarB,SAASqB,WAAW;YAAC;YACpDnD,kBAAkB;gBAAEoD,WAAWtB,SAASsB,SAAS;YAAC;YAClDnD,gBAAgB;gBAAEoD,SAASvB,SAASuB,OAAO;YAAC;YAC5CnD,aAAa;gBAAEoD,UAAUxB,SAASwB,QAAQ;YAAC;YAC3CnD,cAAc;gBAAEoD,OAAOzB,SAASyB,KAAK;YAAC;SACvC;QAED,IAAInC,wBAAwByB,SAASW,IAAI,eAAC,KAACC;YAAKC,MAAK;;QAErD,qBACE;sBACGb,SAASc,GAAG,CAAC,CAACC,IAAIC;gBACjB,qBAAOtE,MAAMuE,YAAY,CAACF,IAA0B;oBAAEG,KAAKF;gBAAM;YACnE;;IAGN;IAEA,eAAeG;QACb,MAAMhC,QAAQ,MAAMR;QACpB,IAAIQ,OAAO;YACT,MAAMA;QACR;QACA,OAAO;IACT;IAEA,OAAO;QAACL;QAAcqC;KAAe;AACvC"}