{"version":3,"sources":["../../../src/build/flying-shuttle/store-shuttle.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport {\n  BUILD_MANIFEST,\n  APP_BUILD_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  APP_PATH_ROUTES_MANIFEST,\n  PAGES_MANIFEST,\n  ROUTES_MANIFEST,\n} from '../../shared/lib/constants'\nimport { recursiveCopy } from '../../lib/recursive-copy'\n\n// we can create a new shuttle with the outputs before env values have\n// been inlined, can be done after stitching takes place\nexport async function storeShuttle({\n  distDir,\n  shuttleDir,\n}: {\n  distDir: string\n  shuttleDir: string\n}) {\n  await fs.promises.rm(shuttleDir, { force: true, recursive: true })\n  await fs.promises.mkdir(shuttleDir, { recursive: true })\n\n  // copy all server entries\n  await recursiveCopy(\n    path.join(distDir, 'server'),\n    path.join(shuttleDir, 'server'),\n    {\n      filter(item) {\n        return !item.match(/\\.(rsc|meta|html)$/)\n      },\n    }\n  )\n\n  const pagesManifest = JSON.parse(\n    await fs.promises.readFile(\n      path.join(shuttleDir, 'server', PAGES_MANIFEST),\n      'utf8'\n    )\n  )\n  // ensure manifest isn't modified to .html as it's before static gen\n  for (const key of Object.keys(pagesManifest)) {\n    pagesManifest[key] = pagesManifest[key].replace(/\\.html$/, '.js')\n  }\n  await fs.promises.writeFile(\n    path.join(shuttleDir, 'server', PAGES_MANIFEST),\n    JSON.stringify(pagesManifest)\n  )\n\n  // copy static assets\n  await recursiveCopy(\n    path.join(distDir, 'static'),\n    path.join(shuttleDir, 'static')\n  )\n\n  // copy manifests not nested in {distDir}/server/\n  await fs.promises.mkdir(path.join(shuttleDir, 'manifests'), {\n    recursive: true,\n  })\n\n  for (const item of [\n    BUILD_MANIFEST,\n    ROUTES_MANIFEST,\n    APP_BUILD_MANIFEST,\n    REACT_LOADABLE_MANIFEST,\n    APP_PATH_ROUTES_MANIFEST,\n  ]) {\n    const outputPath = path.join(shuttleDir, 'manifests', item)\n    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true })\n    await fs.promises.copyFile(path.join(distDir, item), outputPath)\n  }\n}\n"],"names":["fs","path","BUILD_MANIFEST","APP_BUILD_MANIFEST","REACT_LOADABLE_MANIFEST","APP_PATH_ROUTES_MANIFEST","PAGES_MANIFEST","ROUTES_MANIFEST","recursiveCopy","storeShuttle","distDir","shuttleDir","promises","rm","force","recursive","mkdir","join","filter","item","match","pagesManifest","JSON","parse","readFile","key","Object","keys","replace","writeFile","stringify","outputPath","dirname","copyFile"],"mappings":"AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AACvB,SACEC,cAAc,EACdC,kBAAkB,EAClBC,uBAAuB,EACvBC,wBAAwB,EACxBC,cAAc,EACdC,eAAe,QACV,6BAA4B;AACnC,SAASC,aAAa,QAAQ,2BAA0B;AAExD,sEAAsE;AACtE,wDAAwD;AACxD,OAAO,eAAeC,aAAa,EACjCC,OAAO,EACPC,UAAU,EAIX;IACC,MAAMX,GAAGY,QAAQ,CAACC,EAAE,CAACF,YAAY;QAAEG,OAAO;QAAMC,WAAW;IAAK;IAChE,MAAMf,GAAGY,QAAQ,CAACI,KAAK,CAACL,YAAY;QAAEI,WAAW;IAAK;IAEtD,0BAA0B;IAC1B,MAAMP,cACJP,KAAKgB,IAAI,CAACP,SAAS,WACnBT,KAAKgB,IAAI,CAACN,YAAY,WACtB;QACEO,QAAOC,IAAI;YACT,OAAO,CAACA,KAAKC,KAAK,CAAC;QACrB;IACF;IAGF,MAAMC,gBAAgBC,KAAKC,KAAK,CAC9B,MAAMvB,GAAGY,QAAQ,CAACY,QAAQ,CACxBvB,KAAKgB,IAAI,CAACN,YAAY,UAAUL,iBAChC;IAGJ,oEAAoE;IACpE,KAAK,MAAMmB,OAAOC,OAAOC,IAAI,CAACN,eAAgB;QAC5CA,aAAa,CAACI,IAAI,GAAGJ,aAAa,CAACI,IAAI,CAACG,OAAO,CAAC,WAAW;IAC7D;IACA,MAAM5B,GAAGY,QAAQ,CAACiB,SAAS,CACzB5B,KAAKgB,IAAI,CAACN,YAAY,UAAUL,iBAChCgB,KAAKQ,SAAS,CAACT;IAGjB,qBAAqB;IACrB,MAAMb,cACJP,KAAKgB,IAAI,CAACP,SAAS,WACnBT,KAAKgB,IAAI,CAACN,YAAY;IAGxB,iDAAiD;IACjD,MAAMX,GAAGY,QAAQ,CAACI,KAAK,CAACf,KAAKgB,IAAI,CAACN,YAAY,cAAc;QAC1DI,WAAW;IACb;IAEA,KAAK,MAAMI,QAAQ;QACjBjB;QACAK;QACAJ;QACAC;QACAC;KACD,CAAE;QACD,MAAM0B,aAAa9B,KAAKgB,IAAI,CAACN,YAAY,aAAaQ;QACtD,MAAMnB,GAAGY,QAAQ,CAACI,KAAK,CAACf,KAAK+B,OAAO,CAACD,aAAa;YAAEhB,WAAW;QAAK;QACpE,MAAMf,GAAGY,QAAQ,CAACqB,QAAQ,CAAChC,KAAKgB,IAAI,CAACP,SAASS,OAAOY;IACvD;AACF"}