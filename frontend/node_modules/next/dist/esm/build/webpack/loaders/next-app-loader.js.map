{"version":3,"sources":["../../../../src/build/webpack/loaders/next-app-loader.ts"],"sourcesContent":["import type webpack from 'next/dist/compiled/webpack/webpack'\nimport {\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n  type ValueOf,\n} from '../../../shared/lib/constants'\nimport type { ModuleReference, CollectedMetadata } from './metadata/types'\n\nimport path from 'path'\nimport { stringify } from 'querystring'\nimport { bold } from '../../../lib/picocolors'\nimport { getModuleBuildInfo } from './get-module-build-info'\nimport { verifyRootLayout } from '../../../lib/verify-root-layout'\nimport * as Log from '../../output/log'\nimport { APP_DIR_ALIAS, WEBPACK_RESOURCE_QUERIES } from '../../../lib/constants'\nimport {\n  createMetadataExportsCode,\n  createStaticMetadataFromRoute,\n} from './metadata/discover'\nimport { promises as fs } from 'fs'\nimport { isAppRouteRoute } from '../../../lib/is-app-route-route'\nimport { isMetadataRoute } from '../../../lib/metadata/is-metadata-route'\nimport type { NextConfig } from '../../../server/config-shared'\nimport { AppPathnameNormalizer } from '../../../server/normalizers/built/app/app-pathname-normalizer'\nimport { AppBundlePathNormalizer } from '../../../server/normalizers/built/app/app-bundle-path-normalizer'\nimport type { MiddlewareConfig } from '../../analysis/get-page-static-info'\nimport { getFilenameAndExtension } from './next-metadata-route-loader'\nimport { isAppBuiltinNotFoundPage } from '../../utils'\nimport { loadEntrypoint } from '../../load-entrypoint'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { getFilesInDir } from '../../../lib/get-files-in-dir'\nimport type { PageExtensions } from '../../page-extensions-type'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../../client/components/parallel-route-default'\n\nexport type AppLoaderOptions = {\n  name: string\n  page: string\n  pagePath: string\n  appDir: string\n  appPaths: readonly string[] | null\n  preferredRegion: string | string[] | undefined\n  pageExtensions: PageExtensions\n  assetPrefix: string\n  rootDir?: string\n  tsconfigPath?: string\n  isDev?: true\n  basePath: string\n  flyingShuttle?: boolean\n  nextConfigOutput?: NextConfig['output']\n  nextConfigExperimentalUseEarlyImport?: true\n  middlewareConfig: string\n}\ntype AppLoader = webpack.LoaderDefinitionFunction<AppLoaderOptions>\n\nconst FILE_TYPES = {\n  layout: 'layout',\n  template: 'template',\n  error: 'error',\n  loading: 'loading',\n  'not-found': 'not-found',\n} as const\n\nconst GLOBAL_ERROR_FILE_TYPE = 'global-error'\nconst PAGE_SEGMENT = 'page$'\nconst PARALLEL_CHILDREN_SEGMENT = 'children$'\n\nconst defaultNotFoundPath = 'next/dist/client/components/not-found-error'\nconst defaultGlobalErrorPath = 'next/dist/client/components/error-boundary'\nconst defaultLayoutPath = 'next/dist/client/components/default-layout'\n\ntype DirResolver = (pathToResolve: string) => string\ntype PathResolver = (\n  pathname: string\n) => Promise<string | undefined> | string | undefined\nexport type MetadataResolver = (\n  dir: string,\n  filename: string,\n  extensions: readonly string[]\n) => Promise<string | undefined>\n\nexport type ComponentsType = {\n  readonly [componentKey in ValueOf<typeof FILE_TYPES>]?: ModuleReference\n} & {\n  readonly page?: ModuleReference\n} & {\n  readonly metadata?: CollectedMetadata\n} & {\n  readonly defaultPage?: ModuleReference\n}\n\nasync function createAppRouteCode({\n  name,\n  page,\n  pagePath,\n  resolveAppRoute,\n  pageExtensions,\n  nextConfigOutput,\n}: {\n  name: string\n  page: string\n  pagePath: string\n  resolveAppRoute: PathResolver\n  pageExtensions: PageExtensions\n  nextConfigOutput: NextConfig['output']\n}): Promise<string> {\n  // routePath is the path to the route handler file,\n  // but could be aliased e.g. private-next-app-dir/favicon.ico\n  const routePath = pagePath.replace(/[\\\\/]/, '/')\n\n  // This, when used with the resolver will give us the pathname to the built\n  // route handler file.\n  let resolvedPagePath = await resolveAppRoute(routePath)\n  if (!resolvedPagePath) {\n    throw new Error(\n      `Invariant: could not resolve page path for ${name} at ${routePath}`\n    )\n  }\n\n  // If this is a metadata route, then we need to use the metadata loader for\n  // the route to ensure that the route is generated.\n  const fileBaseName = path.parse(resolvedPagePath).name\n  if (isMetadataRoute(name) && fileBaseName !== 'route') {\n    const { ext } = getFilenameAndExtension(resolvedPagePath)\n    const isDynamicRouteExtension = pageExtensions.includes(ext)\n\n    resolvedPagePath = `next-metadata-route-loader?${stringify({\n      filePath: resolvedPagePath,\n      isDynamicRouteExtension: isDynamicRouteExtension ? '1' : '0',\n    })}!?${WEBPACK_RESOURCE_QUERIES.metadataRoute}`\n  }\n\n  const pathname = new AppPathnameNormalizer().normalize(page)\n  const bundlePath = new AppBundlePathNormalizer().normalize(page)\n\n  return await loadEntrypoint(\n    'app-route',\n    {\n      VAR_USERLAND: resolvedPagePath,\n      VAR_DEFINITION_PAGE: page,\n      VAR_DEFINITION_PATHNAME: pathname,\n      VAR_DEFINITION_FILENAME: fileBaseName,\n      VAR_DEFINITION_BUNDLE_PATH: bundlePath,\n      VAR_RESOLVED_PAGE_PATH: resolvedPagePath,\n    },\n    {\n      nextConfigOutput: JSON.stringify(nextConfigOutput),\n    }\n  )\n}\n\nconst normalizeParallelKey = (key: string) =>\n  key.startsWith('@') ? key.slice(1) : key\n\nconst isDirectory = async (pathname: string) => {\n  try {\n    const stat = await fs.stat(pathname)\n    return stat.isDirectory()\n  } catch (err) {\n    return false\n  }\n}\n\nasync function createTreeCodeFromPath(\n  pagePath: string,\n  {\n    page,\n    resolveDir,\n    resolver,\n    resolveParallelSegments,\n    metadataResolver,\n    pageExtensions,\n    basePath,\n    buildInfo,\n    flyingShuttle,\n    collectedDeclarations,\n  }: {\n    page: string\n    flyingShuttle?: boolean\n    buildInfo: ReturnType<typeof getModuleBuildInfo>\n    resolveDir: DirResolver\n    resolver: PathResolver\n    metadataResolver: MetadataResolver\n    resolveParallelSegments: (\n      pathname: string\n    ) => [key: string, segment: string | string[]][]\n    loaderContext: webpack.LoaderContext<AppLoaderOptions>\n    pageExtensions: PageExtensions\n    basePath: string\n    collectedDeclarations: [string, string][]\n  }\n): Promise<{\n  treeCode: string\n  pages: string\n  rootLayout: string | undefined\n  globalError: string\n}> {\n  const splittedPath = pagePath.split(/[\\\\/]/, 1)\n  const isNotFoundRoute = page === UNDERSCORE_NOT_FOUND_ROUTE_ENTRY\n\n  const isDefaultNotFound = isAppBuiltinNotFoundPage(pagePath)\n  const appDirPrefix = isDefaultNotFound ? APP_DIR_ALIAS : splittedPath[0]\n  const hasRootNotFound = await resolver(\n    `${appDirPrefix}/${FILE_TYPES['not-found']}`\n  )\n  const pages: string[] = []\n\n  let rootLayout: string | undefined\n  let globalError: string | undefined\n\n  async function resolveAdjacentParallelSegments(\n    segmentPath: string\n  ): Promise<string[]> {\n    const absoluteSegmentPath = await resolveDir(\n      `${appDirPrefix}${segmentPath}`\n    )\n\n    if (!absoluteSegmentPath) {\n      return []\n    }\n\n    const segmentIsDirectory = await isDirectory(absoluteSegmentPath)\n\n    if (!segmentIsDirectory) {\n      return []\n    }\n\n    // We need to resolve all parallel routes in this level.\n    const files = await fs.opendir(absoluteSegmentPath)\n\n    const parallelSegments: string[] = ['children']\n\n    for await (const dirent of files) {\n      // Make sure name starts with \"@\" and is a directory.\n      if (dirent.isDirectory() && dirent.name.charCodeAt(0) === 64) {\n        parallelSegments.push(dirent.name)\n      }\n    }\n\n    return parallelSegments\n  }\n\n  async function createSubtreePropsFromSegmentPath(\n    segments: string[],\n    nestedCollectedDeclarations: [string, string][]\n  ): Promise<{\n    treeCode: string\n  }> {\n    const segmentPath = segments.join('/')\n\n    // Existing tree are the children of the current segment\n    const props: Record<string, string> = {}\n    // Root layer could be 1st layer of normal routes\n    const isRootLayer = segments.length === 0\n    const isRootLayoutOrRootPage = segments.length <= 1\n\n    // We need to resolve all parallel routes in this level.\n    const parallelSegments: [key: string, segment: string | string[]][] = []\n    if (isRootLayer) {\n      parallelSegments.push(['children', ''])\n    } else {\n      parallelSegments.push(...resolveParallelSegments(segmentPath))\n    }\n\n    let metadata: Awaited<ReturnType<typeof createStaticMetadataFromRoute>> =\n      null\n    const routerDirPath = `${appDirPrefix}${segmentPath}`\n    // For default not-found, don't traverse the directory to find metadata.\n    const resolvedRouteDir = isDefaultNotFound\n      ? ''\n      : await resolveDir(routerDirPath)\n\n    if (resolvedRouteDir) {\n      metadata = await createStaticMetadataFromRoute(resolvedRouteDir, {\n        basePath,\n        segment: segmentPath,\n        metadataResolver,\n        isRootLayoutOrRootPage,\n        pageExtensions,\n      })\n    }\n\n    for (const [parallelKey, parallelSegment] of parallelSegments) {\n      // if parallelSegment is the page segment (ie, `page$` and not ['page$']), it gets loaded into the __PAGE__ slot\n      // as it's the page for the current route.\n      if (parallelSegment === PAGE_SEGMENT) {\n        const matchedPagePath = `${appDirPrefix}${segmentPath}${\n          parallelKey === 'children' ? '' : `/${parallelKey}`\n        }/page`\n\n        const resolvedPagePath = await resolver(matchedPagePath)\n        if (resolvedPagePath) {\n          pages.push(resolvedPagePath)\n\n          const varName = `page${nestedCollectedDeclarations.length}`\n          nestedCollectedDeclarations.push([varName, resolvedPagePath])\n\n          // Use '' for segment as it's the page. There can't be a segment called '' so this is the safest way to add it.\n          props[normalizeParallelKey(parallelKey)] =\n            `['${PAGE_SEGMENT_KEY}', {}, {\n          page: [${varName}, ${JSON.stringify(resolvedPagePath)}],\n          ${createMetadataExportsCode(metadata)}\n        }]`\n          continue\n        }\n      }\n\n      // if the parallelSegment was not matched to the __PAGE__ slot, then it's a parallel route at this level.\n      // the code below recursively traverses the parallel slots directory to match the corresponding __PAGE__ for each parallel slot\n      // while also filling in layout/default/etc files into the loader tree at each segment level.\n\n      const subSegmentPath = [...segments]\n      if (parallelKey !== 'children') {\n        // A `children` parallel key should have already been processed in the above segment\n        // So we exclude it when constructing the subsegment path for the remaining segment levels\n        subSegmentPath.push(parallelKey)\n      }\n\n      const normalizedParallelSegment = Array.isArray(parallelSegment)\n        ? parallelSegment[0]\n        : parallelSegment\n\n      if (\n        normalizedParallelSegment !== PAGE_SEGMENT &&\n        normalizedParallelSegment !== PARALLEL_CHILDREN_SEGMENT\n      ) {\n        // If we don't have a page segment, nor a special $children marker, it means we need to traverse the next directory\n        // (ie, `normalizedParallelSegment` would correspond with the folder that contains the next level of pages/layout/etc)\n        // we push it to the subSegmentPath so that we can fill in the loader tree for that segment.\n        subSegmentPath.push(normalizedParallelSegment)\n      }\n\n      const parallelSegmentPath = subSegmentPath.join('/')\n\n      // Fill in the loader tree for all of the special files types (layout, default, etc) at this level\n      // `page` is not included here as it's added above.\n      const filePaths = await Promise.all(\n        Object.values(FILE_TYPES).map(async (file) => {\n          return [\n            file,\n            await resolver(\n              `${appDirPrefix}${\n                // TODO-APP: parallelSegmentPath sometimes ends in `/` but sometimes it doesn't. This should be consistent.\n                parallelSegmentPath.endsWith('/')\n                  ? parallelSegmentPath\n                  : parallelSegmentPath + '/'\n              }${file}`\n            ),\n          ] as const\n        })\n      )\n\n      const definedFilePaths = filePaths.filter(([, filePath]) => {\n        if (filePath !== undefined) {\n          if (flyingShuttle && buildInfo.route?.relatedModules) {\n            buildInfo.route.relatedModules.push(filePath)\n          }\n          return true\n        }\n        return false\n      }) as [ValueOf<typeof FILE_TYPES>, string][]\n\n      // Add default not found error as root not found if not present\n      const hasNotFoundFile = definedFilePaths.some(\n        ([type]) => type === 'not-found'\n      )\n      // If the first layer is a group route, we treat it as root layer\n      const isFirstLayerGroupRoute =\n        segments.length === 1 &&\n        subSegmentPath.filter((seg) => isGroupSegment(seg)).length === 1\n      if ((isRootLayer || isFirstLayerGroupRoute) && !hasNotFoundFile) {\n        // If you already have a root not found, don't insert default not-found to group routes root\n        if (!(hasRootNotFound && isFirstLayerGroupRoute)) {\n          definedFilePaths.push(['not-found', defaultNotFoundPath])\n        }\n      }\n\n      if (!rootLayout) {\n        const layoutPath = definedFilePaths.find(\n          ([type]) => type === 'layout'\n        )?.[1]\n        rootLayout = layoutPath\n\n        if (isDefaultNotFound && !layoutPath && !rootLayout) {\n          rootLayout = defaultLayoutPath\n          definedFilePaths.push(['layout', rootLayout])\n        }\n      }\n\n      if (!globalError) {\n        const resolvedGlobalErrorPath = await resolver(\n          `${appDirPrefix}/${GLOBAL_ERROR_FILE_TYPE}`\n        )\n        if (resolvedGlobalErrorPath) {\n          globalError = resolvedGlobalErrorPath\n        }\n      }\n\n      let parallelSegmentKey = Array.isArray(parallelSegment)\n        ? parallelSegment[0]\n        : parallelSegment\n\n      // normalize the parallel segment key to remove any special markers that we inserted in the\n      // earlier logic (such as children$ and page$). These should never appear in the loader tree, and\n      // should instead be the corresponding segment keys (ie `__PAGE__`) or the `children` parallel route.\n      parallelSegmentKey =\n        parallelSegmentKey === PARALLEL_CHILDREN_SEGMENT\n          ? 'children'\n          : parallelSegmentKey === PAGE_SEGMENT\n            ? PAGE_SEGMENT_KEY\n            : parallelSegmentKey\n\n      const normalizedParallelKey = normalizeParallelKey(parallelKey)\n      let subtreeCode\n      // If it's root not found page, set not-found boundary as children page\n      if (isNotFoundRoute && normalizedParallelKey === 'children') {\n        const notFoundPath =\n          definedFilePaths.find(([type]) => type === 'not-found')?.[1] ??\n          defaultNotFoundPath\n\n        const varName = `notFound${nestedCollectedDeclarations.length}`\n        nestedCollectedDeclarations.push([varName, notFoundPath])\n        subtreeCode = `{\n          children: [${JSON.stringify(UNDERSCORE_NOT_FOUND_ROUTE)}, {\n            children: ['${PAGE_SEGMENT_KEY}', {}, {\n              page: [\n                ${varName},\n                ${JSON.stringify(notFoundPath)}\n              ]\n            }]\n          }, {}]\n        }`\n      }\n\n      const componentsCode = `{\n        ${definedFilePaths\n          .map(([file, filePath]) => {\n            const varName = `component${nestedCollectedDeclarations.length}`\n            nestedCollectedDeclarations.push([varName, filePath])\n            return `'${file}': [${varName}, ${JSON.stringify(filePath)}],`\n          })\n          .join('\\n')}\n        ${createMetadataExportsCode(metadata)}\n      }`\n\n      if (!subtreeCode) {\n        const { treeCode: pageSubtreeCode } =\n          await createSubtreePropsFromSegmentPath(\n            subSegmentPath,\n            nestedCollectedDeclarations\n          )\n\n        subtreeCode = pageSubtreeCode\n      }\n\n      props[normalizedParallelKey] = `[\n        '${parallelSegmentKey}',\n        ${subtreeCode},\n        ${componentsCode}\n      ]`\n    }\n\n    const adjacentParallelSegments =\n      await resolveAdjacentParallelSegments(segmentPath)\n\n    for (const adjacentParallelSegment of adjacentParallelSegments) {\n      if (!props[normalizeParallelKey(adjacentParallelSegment)]) {\n        const actualSegment =\n          adjacentParallelSegment === 'children'\n            ? ''\n            : `/${adjacentParallelSegment}`\n\n        // if a default is found, use that. Otherwise use the fallback, which will trigger a `notFound()`\n        const defaultPath =\n          (await resolver(\n            `${appDirPrefix}${segmentPath}${actualSegment}/default`\n          )) ?? PARALLEL_ROUTE_DEFAULT_PATH\n\n        const varName = `default${nestedCollectedDeclarations.length}`\n        nestedCollectedDeclarations.push([varName, defaultPath])\n        props[normalizeParallelKey(adjacentParallelSegment)] = `[\n          '${DEFAULT_SEGMENT_KEY}',\n          {},\n          {\n            defaultPage: [${varName}, ${JSON.stringify(defaultPath)}],\n          }\n        ]`\n      }\n    }\n    return {\n      treeCode: `{\n        ${Object.entries(props)\n          .map(([key, value]) => `${key}: ${value}`)\n          .join(',\\n')}\n      }`,\n    }\n  }\n\n  const { treeCode } = await createSubtreePropsFromSegmentPath(\n    [],\n    collectedDeclarations\n  )\n\n  return {\n    treeCode: `${treeCode}.children;`,\n    pages: `${JSON.stringify(pages)};`,\n    rootLayout,\n    globalError: globalError ?? defaultGlobalErrorPath,\n  }\n}\n\nfunction createAbsolutePath(appDir: string, pathToTurnAbsolute: string) {\n  return (\n    pathToTurnAbsolute\n      // Replace all POSIX path separators with the current OS path separator\n      .replace(/\\//g, path.sep)\n      .replace(/^private-next-app-dir/, appDir)\n  )\n}\n\nconst nextAppLoader: AppLoader = async function nextAppLoader() {\n  const loaderOptions = this.getOptions()\n  const {\n    name,\n    appDir,\n    appPaths,\n    pagePath,\n    pageExtensions,\n    rootDir,\n    tsconfigPath,\n    isDev,\n    nextConfigOutput,\n    preferredRegion,\n    basePath,\n    flyingShuttle,\n    middlewareConfig: middlewareConfigBase64,\n    nextConfigExperimentalUseEarlyImport,\n  } = loaderOptions\n\n  const buildInfo = getModuleBuildInfo((this as any)._module)\n  const collectedDeclarations: [string, string][] = []\n  const page = name.replace(/^app/, '')\n  const middlewareConfig: MiddlewareConfig = JSON.parse(\n    Buffer.from(middlewareConfigBase64, 'base64').toString()\n  )\n  buildInfo.route = {\n    page,\n    absolutePagePath: createAbsolutePath(appDir, pagePath),\n    preferredRegion,\n    middlewareConfig,\n    relatedModules: [],\n  }\n\n  const extensions = pageExtensions.map((extension) => `.${extension}`)\n\n  const normalizedAppPaths =\n    typeof appPaths === 'string' ? [appPaths] : appPaths || []\n\n  const resolveParallelSegments = (\n    pathname: string\n  ): [string, string | string[]][] => {\n    const matched: Record<string, string | string[]> = {}\n    let existingChildrenPath: string | undefined\n    for (const appPath of normalizedAppPaths) {\n      if (appPath.startsWith(pathname + '/')) {\n        const rest = appPath.slice(pathname.length + 1).split('/')\n\n        // It is the actual page, mark it specially.\n        if (rest.length === 1 && rest[0] === 'page') {\n          existingChildrenPath = appPath\n          matched.children = PAGE_SEGMENT\n          continue\n        }\n\n        const isParallelRoute = rest[0].startsWith('@')\n        if (isParallelRoute) {\n          if (rest.length === 2 && rest[1] === 'page') {\n            // We found a parallel route at this level. We don't want to mark it explicitly as the page segment,\n            // as that should be matched to the `children` slot. Instead, we use an array, to signal to `createSubtreePropsFromSegmentPath`\n            // that it needs to recursively fill in the loader tree code for the parallel route at the appropriate levels.\n            matched[rest[0]] = [PAGE_SEGMENT]\n            continue\n          }\n          // If it was a parallel route but we weren't able to find the page segment (ie, maybe the page is nested further)\n          // we first insert a special marker to ensure that we still process layout/default/etc at the slot level prior to continuing\n          // on to the page segment.\n          matched[rest[0]] = [PARALLEL_CHILDREN_SEGMENT, ...rest.slice(1)]\n          continue\n        }\n\n        if (existingChildrenPath && matched.children !== rest[0]) {\n          // If we get here, it means we already set a `page` segment earlier in the loop,\n          // meaning we already matched a page to the `children` parallel segment.\n          const isIncomingParallelPage = appPath.includes('@')\n          const hasCurrentParallelPage = existingChildrenPath.includes('@')\n\n          if (isIncomingParallelPage) {\n            // The duplicate segment was for a parallel slot. In this case,\n            // rather than throwing an error, we can ignore it since this can happen for valid reasons.\n            // For example, when we attempt to normalize catch-all routes, we'll push potential slot matches so\n            // that they are available in the loader tree when we go to render the page.\n            // We only need to throw an error if the duplicate segment was for a regular page.\n            // For example, /app/(groupa)/page & /app/(groupb)/page is an error since it corresponds\n            // with the same path.\n            continue\n          } else if (!hasCurrentParallelPage && !isIncomingParallelPage) {\n            // Both the current `children` and the incoming `children` are regular pages.\n            throw new Error(\n              `You cannot have two parallel pages that resolve to the same path. Please check ${existingChildrenPath} and ${appPath}. Refer to the route group docs for more information: https://nextjs.org/docs/app/building-your-application/routing/route-groups`\n            )\n          }\n        }\n\n        existingChildrenPath = appPath\n        matched.children = rest[0]\n      }\n    }\n\n    return Object.entries(matched)\n  }\n\n  const resolveDir: DirResolver = (pathToResolve) => {\n    return createAbsolutePath(appDir, pathToResolve)\n  }\n\n  const resolveAppRoute: PathResolver = (pathToResolve) => {\n    return createAbsolutePath(appDir, pathToResolve)\n  }\n\n  // Cached checker to see if a file exists in a given directory.\n  // This can be more efficient than checking them with `fs.stat` one by one\n  // because all the thousands of files are likely in a few possible directories.\n  // Note that it should only be cached for this compilation, not globally.\n  const filesInDir = new Map<string, Set<string>>()\n  const fileExistsInDirectory = async (dirname: string, fileName: string) => {\n    const existingFiles = filesInDir.get(dirname)\n    if (existingFiles) {\n      return existingFiles.has(fileName)\n    }\n    try {\n      const files = await getFilesInDir(dirname)\n      const fileNames = new Set<string>(files)\n      filesInDir.set(dirname, fileNames)\n      return fileNames.has(fileName)\n    } catch (err) {\n      return false\n    }\n  }\n\n  const resolver: PathResolver = async (pathname) => {\n    const absolutePath = createAbsolutePath(appDir, pathname)\n\n    const filenameIndex = absolutePath.lastIndexOf(path.sep)\n    const dirname = absolutePath.slice(0, filenameIndex)\n    const filename = absolutePath.slice(filenameIndex + 1)\n\n    let result: string | undefined\n\n    for (const ext of extensions) {\n      const absolutePathWithExtension = `${absolutePath}${ext}`\n      if (\n        !result &&\n        (await fileExistsInDirectory(dirname, `${filename}${ext}`))\n      ) {\n        result = absolutePathWithExtension\n      }\n      // Call `addMissingDependency` for all files even if they didn't match,\n      // because they might be added or removed during development.\n      this.addMissingDependency(absolutePathWithExtension)\n    }\n\n    return result\n  }\n\n  const metadataResolver: MetadataResolver = async (\n    dirname,\n    filename,\n    exts\n  ) => {\n    const absoluteDir = createAbsolutePath(appDir, dirname)\n\n    let result: string | undefined\n\n    for (const ext of exts) {\n      // Compared to `resolver` above the exts do not have the `.` included already, so it's added here.\n      const filenameWithExt = `${filename}.${ext}`\n      const absolutePathWithExtension = `${absoluteDir}${path.sep}${filenameWithExt}`\n      if (!result && (await fileExistsInDirectory(dirname, filenameWithExt))) {\n        result = absolutePathWithExtension\n      }\n      // Call `addMissingDependency` for all files even if they didn't match,\n      // because they might be added or removed during development.\n      this.addMissingDependency(absolutePathWithExtension)\n    }\n\n    return result\n  }\n\n  if (isAppRouteRoute(name)) {\n    return createAppRouteCode({\n      // TODO: investigate if the local `page` is the same as the loaderOptions.page\n      page: loaderOptions.page,\n      name,\n      pagePath,\n      resolveAppRoute,\n      pageExtensions,\n      nextConfigOutput,\n    })\n  }\n\n  let treeCodeResult = await createTreeCodeFromPath(pagePath, {\n    page,\n    resolveDir,\n    resolver,\n    metadataResolver,\n    resolveParallelSegments,\n    loaderContext: this,\n    pageExtensions,\n    basePath,\n    collectedDeclarations,\n    buildInfo,\n    flyingShuttle,\n  })\n\n  if (!treeCodeResult.rootLayout) {\n    if (!isDev) {\n      // If we're building and missing a root layout, exit the build\n      Log.error(\n        `${bold(\n          pagePath.replace(`${APP_DIR_ALIAS}/`, '')\n        )} doesn't have a root layout. To fix this error, make sure every page has a root layout.`\n      )\n      process.exit(1)\n    } else {\n      // In dev we'll try to create a root layout\n      const [createdRootLayout, rootLayoutPath] = await verifyRootLayout({\n        appDir: appDir,\n        dir: rootDir!,\n        tsconfigPath: tsconfigPath!,\n        pagePath,\n        pageExtensions,\n      })\n      if (!createdRootLayout) {\n        let message = `${bold(\n          pagePath.replace(`${APP_DIR_ALIAS}/`, '')\n        )} doesn't have a root layout. `\n\n        if (rootLayoutPath) {\n          message += `We tried to create ${bold(\n            path.relative(this._compiler?.context ?? '', rootLayoutPath)\n          )} for you but something went wrong.`\n        } else {\n          message +=\n            'To fix this error, make sure every page has a root layout.'\n        }\n\n        throw new Error(message)\n      }\n\n      // Clear fs cache, get the new result with the created root layout.\n      filesInDir.clear()\n      treeCodeResult = await createTreeCodeFromPath(pagePath, {\n        page,\n        resolveDir,\n        resolver,\n        metadataResolver,\n        resolveParallelSegments,\n        loaderContext: this,\n        pageExtensions,\n        basePath,\n        collectedDeclarations,\n        buildInfo,\n        flyingShuttle,\n      })\n    }\n  }\n\n  const pathname = new AppPathnameNormalizer().normalize(page)\n\n  // Prefer to modify next/src/server/app-render/entry-base.ts since this is shared with Turbopack.\n  // Any changes to this code should be reflected in Turbopack's app_source.rs and/or app-renderer.tsx as well.\n  const code = await loadEntrypoint(\n    'app-page',\n    {\n      VAR_DEFINITION_PAGE: page,\n      VAR_DEFINITION_PATHNAME: pathname,\n      VAR_MODULE_GLOBAL_ERROR: treeCodeResult.globalError,\n    },\n    {\n      tree: treeCodeResult.treeCode,\n      pages: treeCodeResult.pages,\n      __next_app_require__: '__webpack_require__',\n      __next_app_load_chunk__: '() => Promise.resolve()',\n    }\n  )\n\n  const header =\n    nextConfigExperimentalUseEarlyImport &&\n    process.env.NODE_ENV === 'production'\n      ? // Evaluate the imported modules early in the generated code\n        collectedDeclarations\n          .map(([varName, modulePath]) => {\n            return `import * as ${varName}_ from ${JSON.stringify(\n              modulePath\n            )};\\nconst ${varName} = () => ${varName}_;\\n`\n          })\n          .join('')\n      : // Lazily evaluate the imported modules in the generated code\n        collectedDeclarations\n          .map(([varName, modulePath]) => {\n            return `const ${varName} = () => import(/* webpackMode: \"eager\" */ ${JSON.stringify(\n              modulePath\n            )});\\n`\n          })\n          .join('')\n\n  return header + code\n}\n\nexport default nextAppLoader\n"],"names":["UNDERSCORE_NOT_FOUND_ROUTE","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","path","stringify","bold","getModuleBuildInfo","verifyRootLayout","Log","APP_DIR_ALIAS","WEBPACK_RESOURCE_QUERIES","createMetadataExportsCode","createStaticMetadataFromRoute","promises","fs","isAppRouteRoute","isMetadataRoute","AppPathnameNormalizer","AppBundlePathNormalizer","getFilenameAndExtension","isAppBuiltinNotFoundPage","loadEntrypoint","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","getFilesInDir","PARALLEL_ROUTE_DEFAULT_PATH","FILE_TYPES","layout","template","error","loading","GLOBAL_ERROR_FILE_TYPE","PAGE_SEGMENT","PARALLEL_CHILDREN_SEGMENT","defaultNotFoundPath","defaultGlobalErrorPath","defaultLayoutPath","createAppRouteCode","name","page","pagePath","resolveAppRoute","pageExtensions","nextConfigOutput","routePath","replace","resolvedPagePath","Error","fileBaseName","parse","ext","isDynamicRouteExtension","includes","filePath","metadataRoute","pathname","normalize","bundlePath","VAR_USERLAND","VAR_DEFINITION_PAGE","VAR_DEFINITION_PATHNAME","VAR_DEFINITION_FILENAME","VAR_DEFINITION_BUNDLE_PATH","VAR_RESOLVED_PAGE_PATH","JSON","normalizeParallelKey","key","startsWith","slice","isDirectory","stat","err","createTreeCodeFromPath","resolveDir","resolver","resolveParallelSegments","metadataResolver","basePath","buildInfo","flyingShuttle","collectedDeclarations","splittedPath","split","isNotFoundRoute","isDefaultNotFound","appDirPrefix","hasRootNotFound","pages","rootLayout","globalError","resolveAdjacentParallelSegments","segmentPath","absoluteSegmentPath","segmentIsDirectory","files","opendir","parallelSegments","dirent","charCodeAt","push","createSubtreePropsFromSegmentPath","segments","nestedCollectedDeclarations","join","props","isRootLayer","length","isRootLayoutOrRootPage","metadata","routerDirPath","resolvedRouteDir","segment","parallelKey","parallelSegment","matchedPagePath","varName","subSegmentPath","normalizedParallelSegment","Array","isArray","parallelSegmentPath","filePaths","Promise","all","Object","values","map","file","endsWith","definedFilePaths","filter","undefined","route","relatedModules","hasNotFoundFile","some","type","isFirstLayerGroupRoute","seg","layoutPath","find","resolvedGlobalErrorPath","parallelSegmentKey","normalizedParallelKey","subtreeCode","notFoundPath","componentsCode","treeCode","pageSubtreeCode","adjacentParallelSegments","adjacentParallelSegment","actualSegment","defaultPath","entries","value","createAbsolutePath","appDir","pathToTurnAbsolute","sep","nextAppLoader","loaderOptions","getOptions","appPaths","rootDir","tsconfigPath","isDev","preferredRegion","middlewareConfig","middlewareConfigBase64","nextConfigExperimentalUseEarlyImport","_module","Buffer","from","toString","absolutePagePath","extensions","extension","normalizedAppPaths","matched","existingChildrenPath","appPath","rest","children","isParallelRoute","isIncomingParallelPage","hasCurrentParallelPage","pathToResolve","filesInDir","Map","fileExistsInDirectory","dirname","fileName","existingFiles","get","has","fileNames","Set","set","absolutePath","filenameIndex","lastIndexOf","filename","result","absolutePathWithExtension","addMissingDependency","exts","absoluteDir","filenameWithExt","treeCodeResult","loaderContext","process","exit","createdRootLayout","rootLayoutPath","dir","message","relative","_compiler","context","clear","code","VAR_MODULE_GLOBAL_ERROR","tree","__next_app_require__","__next_app_load_chunk__","header","env","NODE_ENV","modulePath"],"mappings":"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"}