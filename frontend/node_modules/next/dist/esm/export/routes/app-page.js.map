{"version":3,"sources":["../../../src/export/routes/app-page.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'node:http'\nimport type { ExportRouteResult, FileWriter } from '../types'\nimport type { RenderOpts } from '../../server/app-render/types'\nimport type { NextParsedUrlQuery } from '../../server/request-meta'\nimport type { RouteMetadata } from './types'\n\nimport type {\n  MockedRequest,\n  MockedResponse,\n} from '../../server/lib/mock-request'\nimport { isDynamicUsageError } from '../helpers/is-dynamic-usage-error'\nimport {\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_META_SUFFIX,\n  RSC_PREFETCH_SUFFIX,\n  RSC_SUFFIX,\n} from '../../lib/constants'\nimport { hasNextSupport } from '../../telemetry/ci-info'\nimport { lazyRenderAppPage } from '../../server/route-modules/app-page/module.render'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { NEXT_IS_PRERENDER_HEADER } from '../../client/components/app-router-headers'\n\nexport const enum ExportedAppPageFiles {\n  HTML = 'HTML',\n  FLIGHT = 'FLIGHT',\n  PREFETCH_FLIGHT = 'PREFETCH_FLIGHT',\n  META = 'META',\n  POSTPONED = 'POSTPONED',\n}\n\nexport async function exportAppPage(\n  req: MockedRequest,\n  res: MockedResponse,\n  page: string,\n  path: string,\n  pathname: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  htmlFilepath: string,\n  debugOutput: boolean,\n  isDynamicError: boolean,\n  fileWriter: FileWriter\n): Promise<ExportRouteResult> {\n  let isDefaultNotFound = false\n  // If the page is `/_not-found`, then we should update the page to be `/404`.\n  // UNDERSCORE_NOT_FOUND_ROUTE value used here, however we don't want to import it here as it causes constants to be inlined which we don't want here.\n  if (page === '/_not-found/page') {\n    isDefaultNotFound = true\n    pathname = '/404'\n  }\n\n  try {\n    const result = await lazyRenderAppPage(\n      new NodeNextRequest(req),\n      new NodeNextResponse(res),\n      pathname,\n      query,\n      renderOpts\n    )\n\n    const html = result.toUnchunkedString()\n\n    const { metadata } = result\n    const { flightData, revalidate = false, postponed, fetchTags } = metadata\n\n    // Ensure we don't postpone without having PPR enabled.\n    if (postponed && !renderOpts.experimental.isRoutePPREnabled) {\n      throw new Error('Invariant: page postponed without PPR being enabled')\n    }\n\n    if (revalidate === 0) {\n      if (isDynamicError) {\n        throw new Error(\n          `Page with dynamic = \"error\" encountered dynamic data method on ${path}.`\n        )\n      }\n      const { staticBailoutInfo = {} } = metadata\n\n      if (revalidate === 0 && debugOutput && staticBailoutInfo?.description) {\n        logDynamicUsageWarning({\n          path,\n          description: staticBailoutInfo.description,\n          stack: staticBailoutInfo.stack,\n        })\n      }\n\n      return { revalidate: 0 }\n    }\n    // If page data isn't available, it means that the page couldn't be rendered\n    // properly.\n    else if (!flightData) {\n      throw new Error(`Invariant: failed to get page data for ${path}`)\n    }\n    // If PPR is enabled, we want to emit a prefetch rsc file for the page\n    // instead of the standard rsc. This is because the standard rsc will\n    // contain the dynamic data. We do this if any routes have PPR enabled so\n    // that the cache read/write is the same.\n    else if (renderOpts.experimental.isRoutePPREnabled) {\n      // If PPR is enabled, we should emit the flight data as the prefetch\n      // payload.\n      await fileWriter(\n        ExportedAppPageFiles.PREFETCH_FLIGHT,\n        htmlFilepath.replace(/\\.html$/, RSC_PREFETCH_SUFFIX),\n        flightData\n      )\n    } else {\n      // Writing the RSC payload to a file if we don't have PPR enabled.\n      await fileWriter(\n        ExportedAppPageFiles.FLIGHT,\n        htmlFilepath.replace(/\\.html$/, RSC_SUFFIX),\n        flightData\n      )\n    }\n\n    const headers: OutgoingHttpHeaders = { ...metadata.headers }\n\n    // If we're writing the file to disk, we know it's a prerender.\n    headers[NEXT_IS_PRERENDER_HEADER] = '1'\n\n    if (fetchTags) {\n      headers[NEXT_CACHE_TAGS_HEADER] = fetchTags\n    }\n\n    // Writing static HTML to a file.\n    await fileWriter(\n      ExportedAppPageFiles.HTML,\n      htmlFilepath,\n      html ?? '',\n      'utf8'\n    )\n\n    const isParallelRoute = /\\/@\\w+/.test(page)\n    const isNonSuccessfulStatusCode = res.statusCode > 300\n\n    // When PPR is enabled, we don't always send 200 for routes that have been\n    // pregenerated, so we should grab the status code from the mocked\n    // response.\n    let status: number | undefined = renderOpts.experimental.isRoutePPREnabled\n      ? res.statusCode\n      : undefined\n\n    if (isDefaultNotFound) {\n      // Override the default /_not-found page status code to 404\n      status = 404\n    } else if (isNonSuccessfulStatusCode && !isParallelRoute) {\n      // If it's parallel route the status from mock response is 404\n      status = res.statusCode\n    }\n\n    // Writing the request metadata to a file.\n    const meta: RouteMetadata = {\n      status,\n      headers,\n      postponed,\n    }\n\n    await fileWriter(\n      ExportedAppPageFiles.META,\n      htmlFilepath.replace(/\\.html$/, NEXT_META_SUFFIX),\n      JSON.stringify(meta, null, 2)\n    )\n\n    return {\n      // Only include the metadata if the environment has next support.\n      metadata: hasNextSupport ? meta : undefined,\n      hasEmptyPrelude: Boolean(postponed) && html === '',\n      hasPostponed: Boolean(postponed),\n      revalidate,\n    }\n  } catch (err) {\n    if (!isDynamicUsageError(err)) {\n      throw err\n    }\n\n    // We should fail rendering if a client side rendering bailout\n    // occurred at the page level.\n    if (isBailoutToCSRError(err)) {\n      throw err\n    }\n\n    if (debugOutput) {\n      const { dynamicUsageDescription, dynamicUsageStack } = (renderOpts as any)\n        .store\n\n      logDynamicUsageWarning({\n        path,\n        description: dynamicUsageDescription,\n        stack: dynamicUsageStack,\n      })\n    }\n\n    return { revalidate: 0 }\n  }\n}\n\nfunction logDynamicUsageWarning({\n  path,\n  description,\n  stack,\n}: {\n  path: string\n  description: string\n  stack?: string\n}) {\n  const errMessage = new Error(\n    `Static generation failed due to dynamic usage on ${path}, reason: ${description}`\n  )\n\n  if (stack) {\n    errMessage.stack = errMessage.message + stack.substring(stack.indexOf('\\n'))\n  }\n\n  console.warn(errMessage)\n}\n"],"names":["isDynamicUsageError","NEXT_CACHE_TAGS_HEADER","NEXT_META_SUFFIX","RSC_PREFETCH_SUFFIX","RSC_SUFFIX","hasNextSupport","lazyRenderAppPage","isBailoutToCSRError","NodeNextRequest","NodeNextResponse","NEXT_IS_PRERENDER_HEADER","ExportedAppPageFiles","exportAppPage","req","res","page","path","pathname","query","renderOpts","htmlFilepath","debugOutput","isDynamicError","fileWriter","isDefaultNotFound","result","html","toUnchunkedString","metadata","flightData","revalidate","postponed","fetchTags","experimental","isRoutePPREnabled","Error","staticBailoutInfo","description","logDynamicUsageWarning","stack","replace","headers","isParallelRoute","test","isNonSuccessfulStatusCode","statusCode","status","undefined","meta","JSON","stringify","hasEmptyPrelude","Boolean","hasPostponed","err","dynamicUsageDescription","dynamicUsageStack","store","errMessage","message","substring","indexOf","console","warn"],"mappings":"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"}