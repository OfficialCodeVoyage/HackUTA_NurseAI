{"version":3,"sources":["../../../../src/client/components/router-reducer/prefetch-cache-utils.ts"],"sourcesContent":["import { createHrefFromUrl } from './create-href-from-url'\nimport { fetchServerResponse } from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\nimport type { FetchServerResponseResult } from '../../../server/app-render/types'\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKey(url: URL, nextUrl?: string | null) {\n  const pathnameFromUrl = createHrefFromUrl(\n    url,\n    // Ensures the hash is not part of the cache key as it does not impact the server fetch\n    false\n  )\n\n  // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n  if (nextUrl) {\n    return `${nextUrl}%${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  buildId,\n  prefetchCache,\n  kind,\n}: Pick<\n  ReadonlyReducerState,\n  'nextUrl' | 'prefetchCache' | 'tree' | 'buildId'\n> & {\n  url: URL\n  kind?: PrefetchKind\n}): PrefetchCacheEntry {\n  let existingCacheEntry: PrefetchCacheEntry | undefined = undefined\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl)\n  const interceptionData = prefetchCache.get(interceptionCacheKey)\n\n  if (interceptionData) {\n    existingCacheEntry = interceptionData\n  } else {\n    // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n    const prefetchCacheKey = createPrefetchCacheKey(url)\n    const prefetchData = prefetchCache.get(prefetchCacheKey)\n    if (prefetchData) {\n      existingCacheEntry = prefetchData\n    }\n  }\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n        // rather than assuming the same intent as the previous entry, to be consistent with how we\n        // lazily create prefetch entries when intent is left unspecified.\n        kind: kind ?? PrefetchKind.TEMPORARY,\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    buildId,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n}) {\n  const existingCacheKey = createPrefetchCacheKey(url)\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(url, nextUrl)\n  prefetchCache.set(newCacheKey, existingCacheEntry)\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createPrefetchCacheEntryForInitialLoad({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  kind,\n  data,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n  data: FetchServerResponseResult\n}) {\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.i\n    ? createPrefetchCacheKey(url, nextUrl)\n    : createPrefetchCacheKey(url)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  buildId,\n  prefetchCache,\n}: Pick<\n  ReadonlyReducerState,\n  'nextUrl' | 'tree' | 'buildId' | 'prefetchCache'\n> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      buildId,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.i) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.p) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nconst STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === 'auto') {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === 'full') {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n"],"names":["createHrefFromUrl","fetchServerResponse","PrefetchCacheEntryStatus","PrefetchKind","prefetchQueue","createPrefetchCacheKey","url","nextUrl","pathnameFromUrl","getOrCreatePrefetchCacheEntry","tree","buildId","prefetchCache","kind","existingCacheEntry","undefined","interceptionCacheKey","interceptionData","get","prefetchCacheKey","prefetchData","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","FULL","createLazyPrefetchEntry","TEMPORARY","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createPrefetchCacheEntryForInitialLoad","data","i","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","key","fresh","enqueue","flightRouterState","prefetchKind","then","prefetchResponse","p","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","reusable","stale"],"mappings":"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"}