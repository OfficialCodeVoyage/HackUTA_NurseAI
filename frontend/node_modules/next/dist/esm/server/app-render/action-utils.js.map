{"version":3,"sources":["../../../src/server/app-render/action-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\n\n// This function creates a Flight-acceptable server module map proxy from our\n// Server Reference Manifest similar to our client module map.\n// This is because our manifest contains a lot of internal Next.js data that\n// are relevant to the runtime, workers, etc. that React doesn't need to know.\nexport function createServerModuleMap({\n  serverActionsManifest,\n  pageName,\n}: {\n  serverActionsManifest: ActionManifest\n  pageName: string\n}) {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        return {\n          id: serverActionsManifest[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ][id].workers[normalizeWorkerPageName(pageName)],\n          name: id,\n          chunks: [],\n        }\n      },\n    }\n  )\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string,\n  serverActionsManifest: ActionManifest\n) {\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n  const workerName = normalizeWorkerPageName(pageName)\n\n  // no workers, nothing to forward to\n  if (!workers) return\n\n  // if there is a worker for this page, no need to forward it.\n  if (workers[workerName]) {\n    return\n  }\n\n  // otherwise, grab the first worker that has a handler for this action id\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\n/**\n * The flight entry loader keys actions by bundlePath.\n * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n"],"names":["normalizeAppPath","pathHasPrefix","removePathPrefix","createServerModuleMap","serverActionsManifest","pageName","Proxy","get","_","id","process","env","NEXT_RUNTIME","workers","normalizeWorkerPageName","name","chunks","selectWorkerForForwarding","actionId","workerName","denormalizeWorkerPageName","Object","keys","bundlePath"],"mappings":"AACA,SAASA,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,aAAa,QAAQ,gDAA+C;AAC7E,SAASC,gBAAgB,QAAQ,mDAAkD;AAEnF,6EAA6E;AAC7E,8DAA8D;AAC9D,4EAA4E;AAC5E,8EAA8E;AAC9E,OAAO,SAASC,sBAAsB,EACpCC,qBAAqB,EACrBC,QAAQ,EAIT;IACC,OAAO,IAAIC,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;YACP,OAAO;gBACLA,IAAIL,qBAAqB,CACvBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,SAAS,OAChD,CAACH,GAAG,CAACI,OAAO,CAACC,wBAAwBT,UAAU;gBAChDU,MAAMN;gBACNO,QAAQ,EAAE;YACZ;QACF;IACF;AAEJ;AAEA;;;CAGC,GACD,OAAO,SAASC,0BACdC,QAAgB,EAChBb,QAAgB,EAChBD,qBAAqC;QAGnCA;IADF,MAAMS,WACJT,mCAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,SAAS,OAChD,CAACM,SAAS,qBAFXd,iCAEaS,OAAO;IACtB,MAAMM,aAAaL,wBAAwBT;IAE3C,oCAAoC;IACpC,IAAI,CAACQ,SAAS;IAEd,6DAA6D;IAC7D,IAAIA,OAAO,CAACM,WAAW,EAAE;QACvB;IACF;IAEA,yEAAyE;IACzE,OAAOC,0BAA0BC,OAAOC,IAAI,CAACT,QAAQ,CAAC,EAAE;AAC1D;AAEA;;;CAGC,GACD,SAASC,wBAAwBT,QAAgB;IAC/C,IAAIJ,cAAcI,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;CAEC,GACD,SAASe,0BAA0BG,UAAkB;IACnD,OAAOvB,iBAAiBE,iBAAiBqB,YAAY;AACvD"}