{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  FlightSegmentPath,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n} from './types'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { RequestStore } from '../../client/components/request-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { Revalidate } from '../lib/revalidate'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n  type RenderResultResponse,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  continueDynamicDataResume,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  createMetadataComponents,\n  createMetadataContext,\n} from '../../lib/metadata/metadata'\nimport { withRequestStore } from '../async-storage/with-request-store'\nimport { withStaticGenerationStore } from '../async-storage/with-static-generation-store'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport {\n  getURLFromRedirectError,\n  isRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { addImplicitTags } from '../lib/patch-fetch'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createErrorHandler,\n  type DigestedError,\n  type ErrorHandler,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport {\n  getTracedMetadata,\n  makeGetServerInsertedHTML,\n} from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  createStaticRenderer,\n  DYNAMIC_DATA,\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  type PostponedState,\n} from './static/static-renderer'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n  flightRenderComplete,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  usedDynamicAPIs,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../shared/lib/router/action-queue'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\ntype AppRenderBaseContext = {\n  staticGenerationStore: StaticGenerationStore\n  requestStore: RequestStore\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n}\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppRenderContext = AppRenderBaseContext & {\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  defaultRevalidate: Revalidate\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  flightDataRendererErrorHandler: ErrorHandler\n  serverComponentsErrorHandler: ErrorHandler\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isRoutePPREnabled: boolean\n}\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isPrefetchRequest =\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  const isRSCRequest = headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    nonce,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  return ['', {}, loaderTree[2]]\n}\n\nexport type CreateSegmentPath = (child: FlightSegmentPath) => FlightSegmentPath\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({ ctx }: { ctx: AppRenderContext }) {\n  const is404Page = ctx.pagePath === '/404'\n  const isInvalidStatusCode =\n    typeof ctx.res.statusCode === 'number' && ctx.res.statusCode > 400\n\n  if (is404Page || isInvalidStatusCode) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    asNotFound?: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n  let flightData: FlightData | null = null\n\n  const {\n    componentMod: { tree: loaderTree, createDynamicallyTrackedSearchParams },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    requestStore: { url },\n    query,\n    requestId,\n    flightRouterState,\n  } = ctx\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const [MetadataTree, MetadataOutlet] = createMetadataComponents({\n      tree: loaderTree,\n      query,\n      metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createDynamicallyTrackedSearchParams,\n    })\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        createSegmentPath: (child) => child,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        isFirst: true,\n        // For flight, render metadata inside leaf page\n        rscPayloadHead: (\n          <>\n            <NonIndex ctx={ctx} />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <MetadataTree key={requestId} />\n          </>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        asNotFound: ctx.isNotFoundPath || options?.asNotFound,\n        metadataOutlet: <MetadataOutlet />,\n        preloadCallbacks,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.renderOpts.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.renderOpts.buildId,\n    // Anything besides an action response should have non-null flightData.\n    // We don't ever expect this to be null because `skipFlight` is only\n    // used when invoked by a server action, which is covered above.\n    // The client router can handle an empty string (treating it as an MPA navigation),\n    // so we'll use that as a fallback.\n    f: flightData ?? '',\n  }\n}\n\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    asNotFound?: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n  }\n): Promise<RenderResult> {\n  const rscPayload = await generateDynamicRSCPayload(ctx, options)\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = ctx.componentMod.renderToReadableStream(\n    rscPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError: ctx.flightDataRendererErrorHandler,\n      nonce: ctx.nonce,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.staticGenerationStore.fetchMetrics,\n  })\n}\n\ntype RenderToStreamResult = {\n  stream: RenderResultResponse\n  err?: unknown\n}\n\ntype RenderToStreamOptions = {\n  /**\n   * This option is used to indicate that the page should be rendered as\n   * if it was not found. When it's enabled, instead of rendering the\n   * page component, it renders the not-found segment.\n   *\n   */\n  asNotFound: boolean\n  tree: LoaderTree\n  formState: any\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  asNotFound: boolean\n) {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: { GlobalError, createDynamicallyTrackedSearchParams },\n    requestStore: { url },\n  } = ctx\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  const [MetadataTree, MetadataOutlet] = createMetadataComponents({\n    tree,\n    errorType: asNotFound ? 'not-found' : undefined,\n    query,\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    getDynamicParamFromSegment: getDynamicParamFromSegment,\n    appUsingSizeAdjustment: appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    createSegmentPath: (child) => child,\n    loaderTree: tree,\n    parentParams: {},\n    firstItem: true,\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    asNotFound: asNotFound,\n    metadataOutlet: <MetadataOutlet />,\n    missingSlots,\n    preloadCallbacks,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={ctx.requestId} />\n    </>\n  )\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: url.pathname + url.search,\n    i: couldBeIntercepted,\n    f: [[initialTree, seedData, initialHead]],\n    m: missingSlots,\n    G: GlobalError,\n  } satisfies RSCPayload & { P: React.ReactNode }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  errorType: 'not-found' | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: { GlobalError, createDynamicallyTrackedSearchParams },\n    requestStore: { url },\n    requestId,\n  } = ctx\n\n  const [MetadataTree] = createMetadataComponents({\n    tree,\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    query,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n  })\n\n  const initialHead = (\n    <>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={requestId} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n    </>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const initialSeedData: CacheNodeSeedData = [\n    initialTree[0],\n    {},\n    <html id=\"__next_error__\">\n      <head></head>\n      <body></body>\n    </html>,\n    null,\n  ]\n\n  return {\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: url.pathname + url.search,\n    m: undefined,\n    i: false,\n    f: [[initialTree, initialSeedData, initialHead]],\n    G: GlobalError,\n  } satisfies RSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction ReactServerEntrypoint<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    buildId: response.b,\n    initialFlightData: response.f,\n    initialCanonicalUrl: response.c,\n    // location and initialParallelRoutes are not initialized in the SSR render\n    // they are set to an empty map and window.location, respectively during hydration\n    initialParallelRoutes: null!,\n    location: null,\n    couldBeIntercepted: response.i,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  return (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorComponent={response.G}\n      assetPrefix={response.p}\n    />\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  baseCtx: AppRenderBaseContext,\n  requestEndedState: { ended?: boolean }\n) {\n  const isNotFoundPath = pagePath === '/404'\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    buildManifest,\n    subresourceIntegrityManifest,\n    serverActionsManifest,\n    ComponentMod,\n    dev,\n    nextFontManifest,\n    supportsDynamicResponse,\n    serverActions,\n    onInstrumentationRequestError,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // @ts-ignore\n    globalThis.__next_chunk_load__ = instrumented.loadChunk\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setAppIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      const staticGenStore =\n        ComponentMod.staticGenerationAsyncStorage.getStore()\n\n      if (\n        process.env.NODE_ENV === 'development' &&\n        staticGenStore &&\n        renderOpts.setAppIsrStatus\n      ) {\n        // only node can be ISR so we only need to update the status here\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        let { revalidate } = staticGenStore\n        if (typeof revalidate === 'undefined') {\n          revalidate = false\n        }\n        if (revalidate === false || revalidate > 0) {\n          renderOpts.setAppIsrStatus(pathname, revalidate)\n        }\n      }\n\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({\n    serverActionsManifest,\n    pageName: renderOpts.page,\n  })\n\n  setReferenceManifestsSingleton({\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  const digestErrorsMap: Map<string, DigestedError> = new Map()\n  const allCapturedErrors: Error[] = []\n  const isNextExport = !!renderOpts.nextExport\n  const { staticGenerationStore, requestStore, parsedRequestHeaders } = baseCtx\n  const { isStaticGeneration } = staticGenerationStore\n\n  /**\n   * Sets the headers on the response object. If we're generating static HTML,\n   * we store the headers in the metadata object as well so that they can be\n   * persisted.\n   */\n  const setHeader = isStaticGeneration\n    ? (name: string, value: string | string[]) => {\n        res.setHeader(name, value)\n\n        metadata.headers ??= {}\n        metadata.headers[name] = res.getHeader(name)\n\n        return res\n      }\n    : res.setHeader.bind(res)\n\n  const isRoutePPREnabled = renderOpts.experimental.isRoutePPREnabled === true\n\n  // When static generation fails during PPR, we log the errors separately. We\n  // intentionally silence the error logger in this case to avoid double\n  // logging.\n  const silenceStaticGenerationErrors = isRoutePPREnabled && isStaticGeneration\n  const isActionRequest = getServerActionRequestMetadata(req).isServerAction\n\n  const errorContext: Pick<\n    RequestErrorContext,\n    'routerKind' | 'routePath' | 'routeType'\n  > = {\n    routerKind: 'App Router',\n    routePath: pagePath,\n    routeType: isActionRequest ? 'action' : 'render',\n  }\n\n  // Including RSC rendering and flight data rendering\n  function getRSCError(err: DigestedError) {\n    const digest = err.digest\n    if (!digestErrorsMap.has(digest)) {\n      digestErrorsMap.set(digest, err)\n    }\n    return err\n  }\n\n  function getSSRError(err: DigestedError) {\n    // For SSR errors, if we have the existing digest in errors map,\n    // we should use the existing error object to avoid duplicate error logs.\n    if (digestErrorsMap.has(err.digest)) {\n      return digestErrorsMap.get(err.digest)!\n    }\n    return err\n  }\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return onInstrumentationRequestError?.(err, req, {\n      ...errorContext,\n      renderSource: 'react-server-components-payload',\n    })\n  }\n\n  function onServerRenderError(err: DigestedError) {\n    const renderSource = digestErrorsMap.has(err.digest)\n      ? 'react-server-components'\n      : 'server-rendering'\n    return onInstrumentationRequestError?.(err, req, {\n      ...errorContext,\n      renderSource,\n    })\n  }\n\n  const serverComponentsErrorHandler = createErrorHandler({\n    dev,\n    isNextExport,\n    // RSC rendering error will report as SSR error\n    onReactStreamRenderError: undefined,\n    getErrorByRenderSource: getRSCError,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n  const flightDataRendererErrorHandler = createErrorHandler({\n    dev,\n    isNextExport,\n    onReactStreamRenderError: onFlightDataRenderError,\n    getErrorByRenderSource: getRSCError,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n  const htmlRendererErrorHandler = createErrorHandler({\n    dev,\n    isNextExport,\n    onReactStreamRenderError: onServerRenderError,\n    getErrorByRenderSource: getSSRError,\n    allCapturedErrors,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n\n  ComponentMod.patchFetch()\n\n  if (renderOpts.experimental.after) {\n    ComponentMod.patchCacheScopeSupportIntoReact()\n  }\n\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const generateStaticHTML = supportsDynamicResponse !== true\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  staticGenerationStore.fetchMetrics = []\n  metadata.fetchMetrics = staticGenerationStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const { flightRouterState, isPrefetchRequest, isRSCRequest, nonce } =\n    parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath\n  )\n\n  const ctx: AppRenderContext = {\n    ...baseCtx,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    defaultRevalidate: false,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    flightDataRendererErrorHandler,\n    serverComponentsErrorHandler,\n    isNotFoundPath,\n    nonce,\n    res,\n  }\n\n  if (isRSCRequest && !isStaticGeneration) {\n    return generateDynamicFlightRenderResult(ctx)\n  }\n\n  const validateRootLayout = dev\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  // On each render, create a new `ServerInsertedHTML` context to capture\n  // injected nodes from user code (`useServerInsertedHTML`).\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  getTracer().getRootSpanAttributes()?.set('next.route', pagePath)\n\n  const renderToStream = getTracer().wrap(\n    AppRenderSpan.getBodyResult,\n    {\n      spanName: `render route (app) ${pagePath}`,\n      attributes: {\n        'next.route': pagePath,\n      },\n    },\n    async ({\n      asNotFound,\n      tree,\n      formState,\n    }: RenderToStreamOptions): Promise<RenderToStreamResult> => {\n      const tracingMetadata = getTracedMetadata(\n        getTracer().getTracePropagationData(),\n        renderOpts.experimental.clientTraceMetadata\n      )\n\n      const polyfills: JSX.IntrinsicElements['script'][] =\n        buildManifest.polyfillFiles\n          .filter(\n            (polyfill) =>\n              polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n          )\n          .map((polyfill) => ({\n            src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n              ctx,\n              false\n            )}`,\n            integrity: subresourceIntegrityManifest?.[polyfill],\n            crossOrigin: renderOpts.crossOrigin,\n            noModule: true,\n            nonce,\n          }))\n\n      const [preinitScripts, bootstrapScript] = getRequiredScripts(\n        buildManifest,\n        assetPrefix,\n        renderOpts.crossOrigin,\n        subresourceIntegrityManifest,\n        getAssetQueryString(ctx, true),\n        nonce,\n        renderOpts.page\n      )\n\n      const rscPayload = await getRSCPayload(tree, ctx, asNotFound)\n\n      // We kick off the Flight Request (render) here. It is ok to initiate the render in an arbitrary\n      // place however it is critical that we only construct the Flight Response inside the SSR\n      // render so that directives like preloads are correctly piped through\n      const serverStream = ComponentMod.renderToReadableStream(\n        rscPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: serverComponentsErrorHandler,\n          nonce,\n        }\n      )\n\n      // We are going to consume this render both for SSR and for inlining the flight data\n      let [renderStream, dataStream] = serverStream.tee()\n\n      const children = (\n        <HeadManagerContext.Provider\n          value={{\n            appDir: true,\n            nonce,\n          }}\n        >\n          <ServerInsertedHTMLProvider>\n            <ReactServerEntrypoint\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={nonce}\n            />\n          </ServerInsertedHTMLProvider>\n        </HeadManagerContext.Provider>\n      )\n\n      const isResume = !!renderOpts.postponed\n\n      const onHeaders =\n        // During prerenders, we want to capture the headers created so we can\n        // persist them to the metadata.\n        staticGenerationStore.prerenderState ||\n        // During static generation and during resumes we don't\n        // ask React to emit headers. For Resume this is just not supported\n        // For static generation we know there will be an entire HTML document\n        // output and so moving from tag to header for preloading can only\n        // server to alter preloading priorities in unwanted ways\n        (!isStaticGeneration && !isResume)\n          ? (headers: Headers) => {\n              headers.forEach((value, key) => {\n                setHeader(key, value)\n              })\n            }\n          : undefined\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      let postponed: PostponedState | null = null\n\n      // If provided, the postpone state should be parsed as JSON so it can be\n      // provided to React.\n      if (typeof renderOpts.postponed === 'string') {\n        try {\n          postponed = JSON.parse(renderOpts.postponed)\n        } catch {\n          // If we failed to parse the postponed state, we should default to\n          // performing a dynamic data render.\n          postponed = DYNAMIC_DATA\n        }\n      }\n\n      const renderer = createStaticRenderer({\n        isRoutePPREnabled,\n        isStaticGeneration,\n        postponed,\n        streamOptions: {\n          onError: htmlRendererErrorHandler,\n          onHeaders,\n          maxHeadersLength: 600,\n          nonce,\n          // When debugging the static shell, client-side rendering should be\n          // disabled to prevent blanking out the page.\n          bootstrapScripts: renderOpts.isDebugStaticShell\n            ? []\n            : [bootstrapScript],\n          formState,\n        },\n      })\n\n      let flightRenderResult: FlightRenderResult | undefined = undefined\n\n      // Tee the data stream so that we can create a static flight payload.\n      if (isStaticGeneration) {\n        const [original, flightSpy] = dataStream.tee()\n        dataStream = original\n        flightRenderResult = new FlightRenderResult(flightSpy)\n      }\n\n      try {\n        const result = await renderer.render(children)\n\n        const prerenderState = staticGenerationStore.prerenderState\n        if (prerenderState) {\n          /**\n           * When prerendering there are three outcomes to consider\n           *\n           *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n           *                      We will need to resume this result when requests are handled and we don't include\n           *                      any server inserted HTML or inlined flight data in the static HTML\n           *\n           *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n           *                      resume this render when requests are handled but we will generate new inlined\n           *                      flight data since it is dynamic and differences may end up reconciling on the client\n           *\n           *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n           *                      all server inserted HTML and flight data\n           */\n\n          // We need to provide flightData to the page metadata so it can be written to disk\n          metadata.flightData =\n            await flightRenderResult?.toUnchunkedBuffer(true)\n\n          // First we check if we have any dynamic holes in our HTML prerender\n          if (usedDynamicAPIs(prerenderState)) {\n            if (result.postponed != null) {\n              // This is the Dynamic HTML case.\n              metadata.postponed = JSON.stringify(\n                getDynamicHTMLPostponedState(result.postponed)\n              )\n            } else {\n              // This is the Dynamic Data case\n              metadata.postponed = JSON.stringify(\n                getDynamicDataPostponedState()\n              )\n            }\n            // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n            // server inserted html in the static response because the html that is part of the prerender may depend on it\n            // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n            // require the same set so we unify the code path here\n            return {\n              stream: await continueDynamicPrerender(result.stream, {\n                getServerInsertedHTML,\n              }),\n            }\n          } else {\n            // We may still be rendering the RSC stream even though the HTML is finished.\n            // We wait for the RSC stream to complete and check again if dynamic was used\n            const [original, flightSpy] = dataStream.tee()\n            dataStream = original\n\n            await flightRenderComplete(flightSpy)\n\n            if (usedDynamicAPIs(prerenderState)) {\n              // This is the same logic above just repeated after ensuring the RSC stream itself has completed\n              if (result.postponed != null) {\n                // This is the Dynamic HTML case.\n                metadata.postponed = JSON.stringify(\n                  getDynamicHTMLPostponedState(result.postponed)\n                )\n              } else {\n                // This is the Dynamic Data case\n                metadata.postponed = JSON.stringify(\n                  getDynamicDataPostponedState()\n                )\n              }\n              // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n              // server inserted html in the static response because the html that is part of the prerender may depend on it\n              // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n              // require the same set so we unify the code path here\n              return {\n                stream: await continueDynamicPrerender(result.stream, {\n                  getServerInsertedHTML,\n                }),\n              }\n            } else {\n              // This is the Static case\n              // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n              let renderedHTMLStream = result.stream\n\n              if (staticGenerationStore.forceDynamic) {\n                throw new StaticGenBailoutError(\n                  'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n                )\n              }\n\n              if (result.postponed != null) {\n                // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n                // so we can set all the postponed boundaries to client render mode before we store the HTML response\n                const resumeRenderer = createStaticRenderer({\n                  isRoutePPREnabled,\n                  isStaticGeneration: false,\n                  postponed: getDynamicHTMLPostponedState(result.postponed),\n                  streamOptions: {\n                    signal: createPostponedAbortSignal(\n                      'static prerender resume'\n                    ),\n                    onError: htmlRendererErrorHandler,\n                    nonce,\n                  },\n                })\n\n                // We don't actually want to render anything so we just pass a stream\n                // that never resolves. The resume call is going to abort immediately anyway\n                const foreverStream = new ReadableStream<Uint8Array>()\n\n                const resumeChildren = (\n                  <HeadManagerContext.Provider\n                    value={{\n                      appDir: true,\n                      nonce,\n                    }}\n                  >\n                    <ServerInsertedHTMLProvider>\n                      <ReactServerEntrypoint\n                        reactServerStream={foreverStream}\n                        preinitScripts={() => {}}\n                        clientReferenceManifest={clientReferenceManifest}\n                        nonce={nonce}\n                      />\n                    </ServerInsertedHTMLProvider>\n                  </HeadManagerContext.Provider>\n                )\n\n                const { stream: resumeStream } =\n                  await resumeRenderer.render(resumeChildren)\n                // First we write everything from the prerender, then we write everything from the aborted resume render\n                renderedHTMLStream = chainStreams(result.stream, resumeStream)\n              }\n\n              return {\n                stream: await continueStaticPrerender(renderedHTMLStream, {\n                  inlinedDataStream: createInlinedDataReadableStream(\n                    dataStream,\n                    nonce,\n                    formState\n                  ),\n                  getServerInsertedHTML,\n                }),\n              }\n            }\n          }\n        } else if (renderOpts.postponed) {\n          // This is a continuation of either an Incomplete or Dynamic Data Prerender.\n          const inlinedDataStream = createInlinedDataReadableStream(\n            dataStream,\n            nonce,\n            formState\n          )\n          if (result.resumed) {\n            // We have new HTML to stream and we also need to include server inserted HTML\n            return {\n              stream: await continueDynamicHTMLResume(result.stream, {\n                inlinedDataStream,\n                getServerInsertedHTML,\n              }),\n            }\n          } else {\n            // We are continuing a Dynamic Data Prerender and simply need to append new inlined flight data\n            return {\n              stream: await continueDynamicDataResume(result.stream, {\n                inlinedDataStream,\n              }),\n            }\n          }\n        } else {\n          // This may be a static render or a dynamic render\n          // @TODO factor this further to make the render types more clearly defined and remove\n          // the deluge of optional params that passed to configure the various behaviors\n\n          // Since this is a potentially static branch, we need to provide flightData to the page metadata so it can be written to disk\n          metadata.flightData =\n            await flightRenderResult?.toUnchunkedBuffer(true)\n\n          return {\n            stream: await continueFizzStream(result.stream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                dataStream,\n                nonce,\n                formState\n              ),\n              isStaticGeneration: isStaticGeneration || generateStaticHTML,\n              getServerInsertedHTML,\n              serverInsertedHTMLToHead: true,\n              validateRootLayout,\n            }),\n          }\n        }\n      } catch (err) {\n        if (\n          isStaticGenBailoutError(err) ||\n          (typeof err === 'object' &&\n            err !== null &&\n            'message' in err &&\n            typeof err.message === 'string' &&\n            err.message.includes(\n              'https://nextjs.org/docs/advanced-features/static-html-export'\n            ))\n        ) {\n          // Ensure that \"next dev\" prints the red error overlay\n          throw err\n        }\n\n        // If this is a static generation error, we need to throw it so that it\n        // can be handled by the caller if we're in static generation mode.\n        if (isStaticGeneration && isDynamicServerError(err)) {\n          throw err\n        }\n\n        // If a bailout made it to this point, it means it wasn't wrapped inside\n        // a suspense boundary.\n        const shouldBailoutToCSR = isBailoutToCSRError(err)\n        if (shouldBailoutToCSR) {\n          const stack = getStackWithoutErrorMessage(err)\n          error(\n            `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n          )\n\n          throw err\n        }\n\n        if (isNotFoundError(err)) {\n          res.statusCode = 404\n        }\n        let hasRedirectError = false\n        if (isRedirectError(err)) {\n          hasRedirectError = true\n          res.statusCode = getRedirectStatusCodeFromError(err)\n          if (err.mutableCookies) {\n            const headers = new Headers()\n\n            // If there were mutable cookies set, we need to set them on the\n            // response.\n            if (appendMutableCookies(headers, err.mutableCookies)) {\n              setHeader('set-cookie', Array.from(headers.values()))\n            }\n          }\n          const redirectUrl = addPathPrefix(\n            getURLFromRedirectError(err),\n            renderOpts.basePath\n          )\n          setHeader('Location', redirectUrl)\n        }\n\n        const is404 = ctx.res.statusCode === 404\n        if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {\n          res.statusCode = 500\n        }\n\n        const errorType = is404\n          ? 'not-found'\n          : hasRedirectError\n            ? 'redirect'\n            : undefined\n\n        const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n          buildManifest,\n          assetPrefix,\n          renderOpts.crossOrigin,\n          subresourceIntegrityManifest,\n          getAssetQueryString(ctx, false),\n          nonce,\n          '/_not-found/page'\n        )\n\n        const errorRSCPayload = await getErrorRSCPayload(tree, ctx, errorType)\n\n        const errorServerStream = ComponentMod.renderToReadableStream(\n          errorRSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n            nonce,\n          }\n        )\n\n        try {\n          const fizzStream = await renderToInitialFizzStream({\n            ReactDOMServer: require('react-dom/server.edge'),\n            element: (\n              <ReactServerEntrypoint\n                reactServerStream={errorServerStream}\n                preinitScripts={errorPreinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                nonce={nonce}\n              />\n            ),\n            streamOptions: {\n              nonce,\n              // Include hydration scripts in the HTML\n              bootstrapScripts: [errorBootstrapScript],\n              formState,\n            },\n          })\n\n          // Since this is a potentially static branch, we need to provide flightData to the page metadata so it can be written to disk\n          metadata.flightData =\n            await flightRenderResult?.toUnchunkedBuffer(true)\n\n          return {\n            // Returning the error that was thrown so it can be used to handle\n            // the response in the caller.\n            err,\n            stream: await continueFizzStream(fizzStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                // This is intentionally using the readable datastream from the\n                // main render rather than the flight data from the error page\n                // render\n                dataStream,\n                nonce,\n                formState\n              ),\n              isStaticGeneration,\n              getServerInsertedHTML: makeGetServerInsertedHTML({\n                polyfills,\n                renderServerInsertedHTML,\n                serverCapturedErrors: [],\n                basePath: renderOpts.basePath,\n                tracingMetadata: tracingMetadata,\n              }),\n              serverInsertedHTMLToHead: true,\n              validateRootLayout,\n            }),\n          }\n        } catch (finalErr: any) {\n          if (\n            process.env.NODE_ENV === 'development' &&\n            isNotFoundError(finalErr)\n          ) {\n            const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n              require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n            bailOnNotFound()\n          }\n          throw finalErr\n        }\n      }\n    }\n  )\n\n  // For action requests, we handle them differently with a special render result.\n  const actionRequestResult = await handleAction({\n    req,\n    res,\n    ComponentMod,\n    serverModuleMap,\n    generateFlight: generateDynamicFlightRenderResult,\n    staticGenerationStore,\n    requestStore,\n    serverActions,\n    ctx,\n  })\n\n  let formState: null | any = null\n  if (actionRequestResult) {\n    if (actionRequestResult.type === 'not-found') {\n      const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n      const response = await renderToStream({\n        asNotFound: true,\n        tree: notFoundLoaderTree,\n        formState,\n      })\n\n      return new RenderResult(response.stream, { metadata })\n    } else if (actionRequestResult.type === 'done') {\n      if (actionRequestResult.result) {\n        actionRequestResult.result.assignMetadata(metadata)\n        return actionRequestResult.result\n      } else if (actionRequestResult.formState) {\n        formState = actionRequestResult.formState\n      }\n    }\n  }\n\n  const options: RenderResultOptions = {\n    metadata,\n  }\n\n  let response = await renderToStream({\n    asNotFound: isNotFoundPath,\n    tree: loaderTree,\n    formState,\n  })\n\n  // If we have pending revalidates, wait until they are all resolved.\n  if (staticGenerationStore.pendingRevalidates) {\n    options.waitUntil = Promise.all([\n      staticGenerationStore.incrementalCache?.revalidateTag(\n        staticGenerationStore.revalidatedTags || []\n      ),\n      ...Object.values(staticGenerationStore.pendingRevalidates || {}),\n    ])\n  }\n\n  addImplicitTags(staticGenerationStore, requestStore)\n\n  if (staticGenerationStore.tags) {\n    metadata.fetchTags = staticGenerationStore.tags.join(',')\n  }\n\n  // Create the new render result for the response.\n  const result = new RenderResult(response.stream, options)\n\n  // If we aren't performing static generation, we can return the result now.\n  if (!isStaticGeneration) {\n    return result\n  }\n\n  // If this is static generation, we should read this in now rather than\n  // sending it back to be sent to the client.\n  response.stream = await result.toUnchunkedString(true)\n\n  const buildFailingError =\n    digestErrorsMap.size > 0 ? digestErrorsMap.values().next().value : null\n\n  // If we're debugging partial prerendering, print all the dynamic API accesses\n  // that occurred during the render.\n  if (\n    staticGenerationStore.prerenderState &&\n    usedDynamicAPIs(staticGenerationStore.prerenderState) &&\n    staticGenerationStore.prerenderState?.isDebugDynamicAccesses\n  ) {\n    warn('The following dynamic usage was detected:')\n    for (const access of formatDynamicAPIAccesses(\n      staticGenerationStore.prerenderState\n    )) {\n      warn(access)\n    }\n  }\n\n  // If we encountered any unexpected errors during build we fail the\n  // prerendering phase and the build.\n  if (buildFailingError) {\n    throw buildFailingError\n  }\n\n  // If force static is specifically set to false, we should not revalidate\n  // the page.\n  if (staticGenerationStore.forceStatic === false) {\n    staticGenerationStore.revalidate = 0\n  }\n\n  // Copy the revalidation value onto the render result metadata.\n  metadata.revalidate =\n    staticGenerationStore.revalidate ?? ctx.defaultRevalidate\n\n  // provide bailout info for debugging\n  if (metadata.revalidate === 0) {\n    metadata.staticBailoutInfo = {\n      description: staticGenerationStore.dynamicUsageDescription,\n      stack: staticGenerationStore.dynamicUsageStack,\n    }\n  }\n\n  return new RenderResult(response.stream, options)\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  renderOpts,\n  serverComponentsHmrCache\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n  })\n\n  const { isHmrRefresh } = parsedRequestHeaders\n\n  return withRequestStore(\n    renderOpts.ComponentMod.requestAsyncStorage,\n    {\n      req,\n      url,\n      res,\n      renderOpts,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n    },\n    (requestStore) =>\n      withStaticGenerationStore(\n        renderOpts.ComponentMod.staticGenerationAsyncStorage,\n        {\n          page: renderOpts.routeModule.definition.page,\n          renderOpts,\n          requestEndedState: { ended: false },\n        },\n        (staticGenerationStore) =>\n          renderToHTMLOrFlightImpl(\n            req,\n            res,\n            pagePath,\n            query,\n            renderOpts,\n            {\n              requestStore,\n              staticGenerationStore,\n              componentMod: renderOpts.ComponentMod,\n              renderOpts,\n              parsedRequestHeaders,\n            },\n            staticGenerationStore.requestEndedState || {}\n          )\n      )\n  )\n}\n"],"names":["React","RenderResult","chainStreams","renderToInitialFizzStream","continueFizzStream","continueDynamicPrerender","continueStaticPrerender","continueDynamicHTMLResume","continueDynamicDataResume","stripInternalQueries","NEXT_HMR_REFRESH_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_HEADER","createMetadataComponents","createMetadataContext","withRequestStore","withStaticGenerationStore","isNotFoundError","getURLFromRedirectError","isRedirectError","getRedirectStatusCodeFromError","addImplicitTags","AppRenderSpan","NextNodeServerSpan","getTracer","FlightRenderResult","createErrorHandler","getShortDynamicParamType","dynamicParamTypes","getSegmentParam","getScriptNonceFromHeader","parseAndValidateFlightRouterState","createFlightRouterStateFromLoaderTree","handleAction","isBailoutToCSRError","warn","error","appendMutableCookies","createServerInsertedHTML","getRequiredScripts","addPathPrefix","getTracedMetadata","makeGetServerInsertedHTML","walkTreeWithFlightRouterState","createComponentTree","getAssetQueryString","setReferenceManifestsSingleton","createStaticRenderer","DYNAMIC_DATA","getDynamicDataPostponedState","getDynamicHTMLPostponedState","isDynamicServerError","useFlightStream","createInlinedDataReadableStream","flightRenderComplete","StaticGenBailoutError","isStaticGenBailoutError","getStackWithoutErrorMessage","usedDynamicAPIs","createPostponedAbortSignal","formatDynamicAPIAccesses","getClientComponentLoaderMetrics","wrapClientComponentLoader","createServerModuleMap","isNodeNextRequest","parseParameter","parseRelativeUrl","AppRouter","getServerActionRequestMetadata","createInitialRouterState","createMutableActionQueue","parseRequestHeaders","headers","options","isPrefetchRequest","toLowerCase","undefined","isHmrRefresh","isRSCRequest","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","csp","nonce","createNotFoundLoaderTree","loaderTree","makeGetDynamicParamFromSegment","params","pagePath","getDynamicParamFromSegment","segment","segmentParam","key","param","value","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","treeSegment","split","slice","flatMap","pathSegment","join","NonIndex","ctx","is404Page","isInvalidStatusCode","res","statusCode","meta","name","content","generateDynamicRSCPayload","flightData","componentMod","tree","createDynamicallyTrackedSearchParams","appUsingSizeAdjustment","requestStore","url","query","requestId","skipFlight","preloadCallbacks","MetadataTree","MetadataOutlet","metadataContext","pathname","renderOpts","createSegmentPath","child","loaderTreeToFilter","parentParams","isFirst","rscPayloadHead","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","asNotFound","isNotFoundPath","metadataOutlet","path","actionResult","a","f","b","buildId","generateDynamicFlightRenderResult","rscPayload","flightReadableStream","renderToReadableStream","clientReferenceManifest","clientModules","onError","flightDataRendererErrorHandler","fetchMetrics","staticGenerationStore","getRSCPayload","missingSlots","process","env","NODE_ENV","GlobalError","initialTree","errorType","seedData","firstItem","varyHeader","getHeader","couldBeIntercepted","includes","initialHead","P","Preloads","p","assetPrefix","c","search","m","G","forEach","preloadFn","getErrorRSCPayload","initialSeedData","html","id","head","body","ReactServerEntrypoint","reactServerStream","preinitScripts","response","use","initialState","initialFlightData","initialCanonicalUrl","initialParallelRoutes","location","actionQueue","globalErrorComponent","renderToHTMLOrFlightImpl","req","baseCtx","requestEndedState","requestTimestamp","Date","now","buildManifest","subresourceIntegrityManifest","serverActionsManifest","ComponentMod","dev","nextFontManifest","supportsDynamicResponse","serverActions","onInstrumentationRequestError","enableTainting","__next_app__","instrumented","globalThis","__next_require__","require","__next_chunk_load__","loadChunk","URL","setAppIsrStatus","NEXT_RUNTIME","originalRequest","on","staticGenStore","staticGenerationAsyncStorage","getStore","revalidate","ended","metrics","reset","startSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","pageName","page","digestErrorsMap","Map","allCapturedErrors","isNextExport","nextExport","parsedRequestHeaders","isStaticGeneration","setHeader","bind","experimental","silenceStaticGenerationErrors","isActionRequest","isServerAction","errorContext","routerKind","routePath","routeType","getRSCError","err","digest","has","set","getSSRError","get","onFlightDataRenderError","renderSource","onServerRenderError","serverComponentsErrorHandler","onReactStreamRenderError","getErrorByRenderSource","silenceLogger","htmlRendererErrorHandler","patchFetch","after","patchCacheScopeSupportIntoReact","generateStaticHTML","taintObjectReference","crypto","randomUUID","nanoid","isPrefetch","defaultRevalidate","validateRootLayout","HeadManagerContext","ServerInsertedHTMLProvider","renderServerInsertedHTML","getRootSpanAttributes","renderToStream","wrap","getBodyResult","spanName","formState","tracingMetadata","getTracePropagationData","clientTraceMetadata","polyfills","polyfillFiles","filter","polyfill","endsWith","src","integrity","crossOrigin","noModule","bootstrapScript","serverStream","renderStream","dataStream","tee","children","Provider","appDir","isResume","postponed","onHeaders","prerenderState","getServerInsertedHTML","serverCapturedErrors","basePath","JSON","parse","renderer","streamOptions","maxHeadersLength","bootstrapScripts","isDebugStaticShell","flightRenderResult","original","flightSpy","result","render","toUnchunkedBuffer","stringify","stream","renderedHTMLStream","forceDynamic","resumeRenderer","signal","foreverStream","ReadableStream","resumeChildren","resumeStream","inlinedDataStream","resumed","serverInsertedHTMLToHead","message","shouldBailoutToCSR","stack","reason","hasRedirectError","mutableCookies","Headers","from","values","redirectUrl","is404","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","ReactDOMServer","element","finalErr","bailOnNotFound","actionRequestResult","generateFlight","notFoundLoaderTree","assignMetadata","pendingRevalidates","waitUntil","Promise","all","incrementalCache","revalidateTag","revalidatedTags","Object","tags","fetchTags","toUnchunkedString","buildFailingError","size","next","isDebugDynamicAccesses","access","forceStatic","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","renderToHTMLOrFlight","serverComponentsHmrCache","Error","requestAsyncStorage","routeModule","definition"],"mappings":"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"}