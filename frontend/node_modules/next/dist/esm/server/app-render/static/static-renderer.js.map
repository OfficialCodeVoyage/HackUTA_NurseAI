{"version":3,"sources":["../../../../src/server/app-render/static/static-renderer.ts"],"sourcesContent":["import type {\n  Options as RenderToReadableStreamOptions,\n  ResumeOptions,\n} from 'react-dom/server.edge'\nimport type { Options as PrerenderOptions } from 'react-dom/static.edge'\n\nimport type { JSX } from 'react'\n\ntype RenderResult = {\n  stream: ReadableStream<Uint8Array>\n  postponed?: object | null\n  resumed?: boolean\n}\n\nexport interface Renderer {\n  render(children: JSX.Element): Promise<RenderResult>\n}\n\nclass StaticRenderer implements Renderer {\n  // this is for tree shaking. Couldn't find a better way to do it for some reason\n  private readonly prerender = (process.env.__NEXT_EXPERIMENTAL_REACT\n    ? require('react-dom/static.edge').prerender\n    : null) as (typeof import('react-dom/static.edge'))['prerender']\n\n  constructor(private readonly options: PrerenderOptions) {}\n\n  public async render(children: JSX.Element) {\n    const { prelude, postponed } = await this.prerender(children, this.options)\n\n    return { stream: prelude, postponed }\n  }\n}\n\nclass StaticResumeRenderer implements Renderer {\n  private readonly resume = require('react-dom/server.edge')\n    .resume as (typeof import('react-dom/server.edge'))['resume']\n\n  constructor(\n    private readonly postponed: object,\n    private readonly options: ResumeOptions\n  ) {}\n\n  public async render(children: JSX.Element) {\n    const stream = await this.resume(children, this.postponed, this.options)\n\n    return { stream, resumed: true }\n  }\n}\n\nexport class ServerRenderer implements Renderer {\n  private readonly renderToReadableStream = require('react-dom/server.edge')\n    .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n  constructor(private readonly options: RenderToReadableStreamOptions) {}\n\n  public async render(children: JSX.Element): Promise<RenderResult> {\n    const stream = await this.renderToReadableStream(children, this.options)\n    return { stream }\n  }\n}\n\nexport class VoidRenderer implements Renderer {\n  public async render(_children: JSX.Element): Promise<RenderResult> {\n    return {\n      stream: new ReadableStream({\n        start(controller) {\n          // Close the stream immediately\n          controller.close()\n        },\n      }),\n      resumed: false,\n    }\n  }\n}\n\n/**\n * This represents all the possible configuration options for each of the\n * available renderers. We pick the specific options we need for each renderer\n * to help the `createStaticRenderer` function. If more options are added to\n * this type they should be added to the `createStaticRenderer` function as\n * well.\n */\ntype StreamOptions = Pick<\n  ResumeOptions & RenderToReadableStreamOptions & PrerenderOptions,\n  | 'onError'\n  | 'onPostpone'\n  | 'onHeaders'\n  | 'maxHeadersLength'\n  | 'nonce'\n  | 'bootstrapScripts'\n  | 'formState'\n  | 'signal'\n>\n\nexport const DYNAMIC_DATA = 1 as const\nexport const DYNAMIC_HTML = 2 as const\n\ntype DynamicDataPostponedState = typeof DYNAMIC_DATA\ntype DynamicHTMLPostponedState = [typeof DYNAMIC_HTML, object]\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport function getDynamicHTMLPostponedState(\n  data: object\n): DynamicHTMLPostponedState {\n  return [DYNAMIC_HTML, data]\n}\n\nexport function getDynamicDataPostponedState(): DynamicDataPostponedState {\n  return DYNAMIC_DATA\n}\n\ntype Options = {\n  /**\n   * Whether or not PPR is enabled for this page. This is used to determine\n   * which renderer to use.\n   */\n  isRoutePPREnabled: boolean\n\n  /**\n   * Whether or not this is a static generation render. This is used to\n   * determine which renderer to use.\n   */\n  isStaticGeneration: boolean\n\n  /**\n   * The postponed state for the render. This is only used when resuming a\n   * prerender that has postponed.\n   */\n  postponed: null | PostponedState\n\n  /**\n   * The options for any of the renderers. This is a union of all the possible\n   * options for each renderer. If additional configuration options are required\n   * for a renderer, they should be added to the `StreamOptions` type and then\n   * added via the `createStaticRenderer` function.\n   */\n  streamOptions: StreamOptions\n}\n\nexport function createStaticRenderer({\n  isRoutePPREnabled,\n  isStaticGeneration,\n  postponed,\n  streamOptions: {\n    signal,\n    onError,\n    onPostpone,\n    onHeaders,\n    maxHeadersLength,\n    nonce,\n    bootstrapScripts,\n    formState,\n  },\n}: Options): Renderer {\n  if (isRoutePPREnabled) {\n    if (isStaticGeneration) {\n      // This is a Prerender\n      return new StaticRenderer({\n        signal,\n        onError,\n        onPostpone,\n        // We want to capture headers because we may not end up with a shell\n        // and being able to send headers is the next best thing\n        onHeaders,\n        maxHeadersLength,\n        bootstrapScripts,\n      })\n    } else {\n      // This is a Resume\n      if (postponed === DYNAMIC_DATA) {\n        // The HTML was complete, we don't actually need to render anything\n        return new VoidRenderer()\n      } else if (postponed) {\n        const reactPostponedState = postponed[1]\n        // The HTML had dynamic holes and we need to resume it\n        return new StaticResumeRenderer(reactPostponedState, {\n          signal,\n          onError,\n          onPostpone,\n          nonce,\n        })\n      }\n    }\n  }\n\n  if (isStaticGeneration) {\n    // This is a static render (without PPR)\n    return new ServerRenderer({\n      signal,\n      onError,\n      // We don't pass onHeaders. In static builds we will either have no output\n      // or the entire page. In either case preload headers aren't necessary and could\n      // alter the prioritiy of relative loading of resources so we opt to keep them\n      // as tags exclusively.\n      nonce,\n      bootstrapScripts,\n      formState,\n    })\n  }\n\n  // This is a dynamic render (without PPR)\n  return new ServerRenderer({\n    signal,\n    onError,\n    // Static renders are streamed in realtime so sending headers early is\n    // generally good because it will likely go out before the shell is ready.\n    onHeaders,\n    maxHeadersLength,\n    nonce,\n    bootstrapScripts,\n    formState,\n  })\n}\n"],"names":["StaticRenderer","constructor","options","prerender","process","env","__NEXT_EXPERIMENTAL_REACT","require","render","children","prelude","postponed","stream","StaticResumeRenderer","resume","resumed","ServerRenderer","renderToReadableStream","VoidRenderer","_children","ReadableStream","start","controller","close","DYNAMIC_DATA","DYNAMIC_HTML","getDynamicHTMLPostponedState","data","getDynamicDataPostponedState","createStaticRenderer","isRoutePPREnabled","isStaticGeneration","streamOptions","signal","onError","onPostpone","onHeaders","maxHeadersLength","nonce","bootstrapScripts","formState","reactPostponedState"],"mappings":"AAkBA,MAAMA;IAMJC,YAAY,AAAiBC,OAAyB,CAAE;aAA3BA,UAAAA;aAJZC,YAAaC,QAAQC,GAAG,CAACC,yBAAyB,GAC/DC,QAAQ,yBAAyBJ,SAAS,GAC1C;IAEqD;IAEzD,MAAaK,OAAOC,QAAqB,EAAE;QACzC,MAAM,EAAEC,OAAO,EAAEC,SAAS,EAAE,GAAG,MAAM,IAAI,CAACR,SAAS,CAACM,UAAU,IAAI,CAACP,OAAO;QAE1E,OAAO;YAAEU,QAAQF;YAASC;QAAU;IACtC;AACF;AAEA,MAAME;IAIJZ,YACE,AAAiBU,SAAiB,EAClC,AAAiBT,OAAsB,CACvC;aAFiBS,YAAAA;aACAT,UAAAA;aALFY,SAASP,QAAQ,yBAC/BO,MAAM;IAKN;IAEH,MAAaN,OAAOC,QAAqB,EAAE;QACzC,MAAMG,SAAS,MAAM,IAAI,CAACE,MAAM,CAACL,UAAU,IAAI,CAACE,SAAS,EAAE,IAAI,CAACT,OAAO;QAEvE,OAAO;YAAEU;YAAQG,SAAS;QAAK;IACjC;AACF;AAEA,OAAO,MAAMC;IAIXf,YAAY,AAAiBC,OAAsC,CAAE;aAAxCA,UAAAA;aAHZe,yBAAyBV,QAAQ,yBAC/CU,sBAAsB;IAE6C;IAEtE,MAAaT,OAAOC,QAAqB,EAAyB;QAChE,MAAMG,SAAS,MAAM,IAAI,CAACK,sBAAsB,CAACR,UAAU,IAAI,CAACP,OAAO;QACvE,OAAO;YAAEU;QAAO;IAClB;AACF;AAEA,OAAO,MAAMM;IACX,MAAaV,OAAOW,SAAsB,EAAyB;QACjE,OAAO;YACLP,QAAQ,IAAIQ,eAAe;gBACzBC,OAAMC,UAAU;oBACd,+BAA+B;oBAC/BA,WAAWC,KAAK;gBAClB;YACF;YACAR,SAAS;QACX;IACF;AACF;AAqBA,OAAO,MAAMS,eAAe,EAAU;AACtC,OAAO,MAAMC,eAAe,EAAU;AAQtC,OAAO,SAASC,6BACdC,IAAY;IAEZ,OAAO;QAACF;QAAcE;KAAK;AAC7B;AAEA,OAAO,SAASC;IACd,OAAOJ;AACT;AA8BA,OAAO,SAASK,qBAAqB,EACnCC,iBAAiB,EACjBC,kBAAkB,EAClBpB,SAAS,EACTqB,eAAe,EACbC,MAAM,EACNC,OAAO,EACPC,UAAU,EACVC,SAAS,EACTC,gBAAgB,EAChBC,KAAK,EACLC,gBAAgB,EAChBC,SAAS,EACV,EACO;IACR,IAAIV,mBAAmB;QACrB,IAAIC,oBAAoB;YACtB,sBAAsB;YACtB,OAAO,IAAI/B,eAAe;gBACxBiC;gBACAC;gBACAC;gBACA,oEAAoE;gBACpE,wDAAwD;gBACxDC;gBACAC;gBACAE;YACF;QACF,OAAO;YACL,mBAAmB;YACnB,IAAI5B,cAAca,cAAc;gBAC9B,mEAAmE;gBACnE,OAAO,IAAIN;YACb,OAAO,IAAIP,WAAW;gBACpB,MAAM8B,sBAAsB9B,SAAS,CAAC,EAAE;gBACxC,sDAAsD;gBACtD,OAAO,IAAIE,qBAAqB4B,qBAAqB;oBACnDR;oBACAC;oBACAC;oBACAG;gBACF;YACF;QACF;IACF;IAEA,IAAIP,oBAAoB;QACtB,wCAAwC;QACxC,OAAO,IAAIf,eAAe;YACxBiB;YACAC;YACA,0EAA0E;YAC1E,gFAAgF;YAChF,8EAA8E;YAC9E,uBAAuB;YACvBI;YACAC;YACAC;QACF;IACF;IAEA,yCAAyC;IACzC,OAAO,IAAIxB,eAAe;QACxBiB;QACAC;QACA,sEAAsE;QACtE,0EAA0E;QAC1EE;QACAC;QACAC;QACAC;QACAC;IACF;AACF"}