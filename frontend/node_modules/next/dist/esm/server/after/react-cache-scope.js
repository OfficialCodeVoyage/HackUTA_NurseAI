import { AsyncLocalStorage } from 'async_hooks';
import { InvariantError } from '../../shared/lib/invariant-error';
export function createCacheScope() {
    const storage = createCacheMap();
    return {
        run: (callback)=>{
            return CacheScopeStorage.run(storage, ()=>callback());
        }
    };
}
const HAS_CACHE_SCOPE = Symbol.for('next.cacheScope');
function createCacheMap() {
    return new Map();
}
function isWithinCacheScope() {
    return !!CacheScopeStorage.getStore();
}
const CacheScopeStorage = new AsyncLocalStorage();
/** forked from packages/react-server/src/flight/ReactFlightServerCache.js */ function resolveCache() {
    const store = CacheScopeStorage.getStore();
    if (store) {
        return store;
    }
    return createCacheMap();
}
/** forked from packages/react-server/src/flight/ReactFlightServerCache.js */ const ScopedCacheDispatcher = {
    getCacheForType (resourceType) {
        if (!isWithinCacheScope()) {
            throw new InvariantError('Expected patched cache dispatcher to run within CacheScopeStorage');
        }
        const cache = resolveCache();
        let entry = cache.get(resourceType);
        if (entry === undefined) {
            entry = resourceType();
            // TODO: Warn if undefined?
            cache.set(resourceType, entry);
        }
        return entry;
    }
};
// #endregion
// #region  injecting the patched dispatcher into React
export function patchCacheScopeSupportIntoReact(React) {
    const internals = getReactServerInternals(React);
    if ('A' in internals) {
        if (internals.A) {
            patchReactCacheDispatcher(internals.A);
        } else {
            patchReactCacheDispatcherWhenSet(internals, 'A');
        }
    } else {
        throw new InvariantError('Could not find cache dispatcher in React internals');
    }
}
function patchReactCacheDispatcher(dispatcher) {
    if (dispatcher[HAS_CACHE_SCOPE]) {
        return;
    }
    const { getCacheForType: originalGetCacheForType } = dispatcher;
    dispatcher.getCacheForType = function(create) {
        if (isWithinCacheScope()) {
            return ScopedCacheDispatcher.getCacheForType(create);
        }
        return originalGetCacheForType.call(this, create);
    };
    dispatcher[HAS_CACHE_SCOPE] = true;
}
function patchReactCacheDispatcherWhenSet(container, key) {
    if (container[HAS_CACHE_SCOPE]) {
        return;
    }
    let current = null;
    Object.defineProperty(container, key, {
        get: ()=>current,
        set: (maybeDispatcher)=>{
            try {
                if (maybeDispatcher) {
                    patchReactCacheDispatcher(maybeDispatcher);
                }
            } catch (err) {
                throw new InvariantError('Could not patch the React cache dispatcher', {
                    cause: err
                });
            }
            current = maybeDispatcher;
        }
    });
    container[HAS_CACHE_SCOPE] = true;
}
const INTERNALS_KEY = '__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE';
function getReactServerInternals(React) {
    const _React = React;
    if (INTERNALS_KEY in _React) {
        return _React[INTERNALS_KEY];
    }
    throw new InvariantError('Could not access React server internals');
} // #endregion

//# sourceMappingURL=react-cache-scope.js.map