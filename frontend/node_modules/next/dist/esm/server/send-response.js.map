{"version":3,"sources":["../../src/server/send-response.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport { isNodeNextResponse } from './base-http/helpers'\n\nimport { pipeToNodeResponse } from './pipe-readable'\nimport { splitCookiesString } from './web/utils'\n\n/**\n * Sends the response on the underlying next response object.\n *\n * @param req the underlying request object\n * @param res the underlying response object\n * @param response the response to send\n */\nexport async function sendResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  response: Response,\n  waitUntil?: Promise<unknown>\n): Promise<void> {\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextResponse(res)\n  ) {\n    // Copy over the response status.\n    res.statusCode = response.status\n    res.statusMessage = response.statusText\n\n    // Copy over the response headers.\n    response.headers?.forEach((value, name) => {\n      // The append handling is special cased for `set-cookie`.\n      if (name.toLowerCase() === 'set-cookie') {\n        // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n        for (const cookie of splitCookiesString(value)) {\n          res.appendHeader(name, cookie)\n        }\n      } else {\n        res.appendHeader(name, value)\n      }\n    })\n\n    /**\n     * The response can't be directly piped to the underlying response. The\n     * following is duplicated from the edge runtime handler.\n     *\n     * See packages/next/server/next-server.ts\n     */\n\n    const { originalResponse } = res\n\n    // A response body must not be sent for HEAD requests. See https://httpwg.org/specs/rfc9110.html#HEAD\n    if (response.body && req.method !== 'HEAD') {\n      await pipeToNodeResponse(response.body, originalResponse, waitUntil)\n    } else {\n      originalResponse.end()\n    }\n  }\n}\n"],"names":["isNodeNextResponse","pipeToNodeResponse","splitCookiesString","sendResponse","req","res","response","waitUntil","process","env","NEXT_RUNTIME","statusCode","status","statusMessage","statusText","headers","forEach","value","name","toLowerCase","cookie","appendHeader","originalResponse","body","method","end"],"mappings":"AACA,SAASA,kBAAkB,QAAQ,sBAAqB;AAExD,SAASC,kBAAkB,QAAQ,kBAAiB;AACpD,SAASC,kBAAkB,QAAQ,cAAa;AAEhD;;;;;;CAMC,GACD,OAAO,eAAeC,aACpBC,GAAoB,EACpBC,GAAqB,EACrBC,QAAkB,EAClBC,SAA4B;IAE5B,IACE,qEAAqE;IACrE,6DAA6D;IAC7DC,QAAQC,GAAG,CAACC,YAAY,KAAK,UAC7BV,mBAAmBK,MACnB;YAKA,kCAAkC;QAClCC;QALA,iCAAiC;QACjCD,IAAIM,UAAU,GAAGL,SAASM,MAAM;QAChCP,IAAIQ,aAAa,GAAGP,SAASQ,UAAU;SAGvCR,oBAAAA,SAASS,OAAO,qBAAhBT,kBAAkBU,OAAO,CAAC,CAACC,OAAOC;YAChC,yDAAyD;YACzD,IAAIA,KAAKC,WAAW,OAAO,cAAc;gBACvC,qFAAqF;gBACrF,KAAK,MAAMC,UAAUlB,mBAAmBe,OAAQ;oBAC9CZ,IAAIgB,YAAY,CAACH,MAAME;gBACzB;YACF,OAAO;gBACLf,IAAIgB,YAAY,CAACH,MAAMD;YACzB;QACF;QAEA;;;;;KAKC,GAED,MAAM,EAAEK,gBAAgB,EAAE,GAAGjB;QAE7B,qGAAqG;QACrG,IAAIC,SAASiB,IAAI,IAAInB,IAAIoB,MAAM,KAAK,QAAQ;YAC1C,MAAMvB,mBAAmBK,SAASiB,IAAI,EAAED,kBAAkBf;QAC5D,OAAO;YACLe,iBAAiBG,GAAG;QACtB;IACF;AACF"}