{"version":3,"sources":["../../../../src/server/web/spec-extension/unstable-cache.ts"],"sourcesContent":["import type { IncrementalCache } from '../../lib/incremental-cache'\n\nimport { CACHE_ONE_YEAR } from '../../../lib/constants'\nimport {\n  addImplicitTags,\n  validateRevalidate,\n  validateTags,\n} from '../../lib/patch-fetch'\nimport { staticGenerationAsyncStorage } from '../../../client/components/static-generation-async-storage.external'\nimport { requestAsyncStorage } from '../../../client/components/request-async-storage.external'\n\ntype Callback = (...args: any[]) => Promise<any>\n\nlet noStoreFetchIdx = 0\n\nasync function cacheNewResult<T>(\n  result: T,\n  incrementalCache: IncrementalCache,\n  cacheKey: string,\n  tags: string[],\n  revalidate: number | false | undefined,\n  fetchIdx: number,\n  fetchUrl: string\n): Promise<unknown> {\n  await incrementalCache.set(\n    cacheKey,\n    {\n      kind: 'FETCH',\n      data: {\n        headers: {},\n        // TODO: handle non-JSON values?\n        body: JSON.stringify(result),\n        status: 200,\n        url: '',\n      },\n      revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,\n    },\n    {\n      revalidate,\n      fetchCache: true,\n      tags,\n      fetchIdx,\n      fetchUrl,\n    }\n  )\n  return\n}\n\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */\nexport function unstable_cache<T extends Callback>(\n  cb: T,\n  keyParts?: string[],\n  options: {\n    /**\n     * The revalidation interval in seconds.\n     */\n    revalidate?: number | false\n    tags?: string[]\n  } = {}\n): T {\n  if (options.revalidate === 0) {\n    throw new Error(\n      `Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`\n    )\n  }\n\n  // Validate the tags provided are valid\n  const tags = options.tags\n    ? validateTags(options.tags, `unstable_cache ${cb.toString()}`)\n    : []\n\n  // Validate the revalidate options\n  validateRevalidate(\n    options.revalidate,\n    `unstable_cache ${cb.name || cb.toString()}`\n  )\n\n  // Stash the fixed part of the key at construction time. The invocation key will combine\n  // the fixed key with the arguments when actually called\n  // @TODO if cb.toString() is long we should hash it\n  // @TODO come up with a collision-free way to combine keyParts\n  // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n  // and the error produced by accidentally using something that cannot be safely coerced is likely\n  // hard to debug\n  const fixedKey = `${cb.toString()}-${\n    Array.isArray(keyParts) && keyParts.join(',')\n  }`\n\n  const cachedCb = async (...args: any[]) => {\n    const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n    const requestStore = requestAsyncStorage.getStore()\n\n    // We must be able to find the incremental cache otherwise we throw\n    const maybeIncrementalCache:\n      | import('../../lib/incremental-cache').IncrementalCache\n      | undefined =\n      staticGenerationStore?.incrementalCache ||\n      (globalThis as any).__incrementalCache\n\n    if (!maybeIncrementalCache) {\n      throw new Error(\n        `Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`\n      )\n    }\n    const incrementalCache = maybeIncrementalCache\n\n    // If there's no request store, we aren't in a request (or we're not in app\n    // router)  and if there's no static generation store, we aren't in app\n    // router. Default to an empty pathname and search params when there's no\n    // request store or static generation store available.\n    const pathname =\n      requestStore?.url.pathname ?? staticGenerationStore?.route ?? ''\n    const searchParams = new URLSearchParams(requestStore?.url.search ?? '')\n\n    const sortedSearchKeys = [...searchParams.keys()].sort((a, b) => {\n      return a.localeCompare(b)\n    })\n    const sortedSearch = sortedSearchKeys\n      .map((key) => `${key}=${searchParams.get(key)}`)\n      .join('&')\n\n    // Construct the complete cache key for this function invocation\n    // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n    // the keyspace smaller than the execution space\n    const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n    const cacheKey = await incrementalCache.generateCacheKey(invocationKey)\n    // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n    const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`\n    const fetchIdx =\n      (staticGenerationStore\n        ? staticGenerationStore.nextFetchId\n        : noStoreFetchIdx) ?? 1\n\n    if (staticGenerationStore) {\n      staticGenerationStore.nextFetchId = fetchIdx + 1\n\n      // We are in an App Router context. We try to return the cached entry if it exists and is valid\n      // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n      // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n      // We update the store's revalidate property if the option.revalidate is a higher precedence\n      if (typeof options.revalidate === 'number') {\n        if (\n          typeof staticGenerationStore.revalidate === 'number' &&\n          staticGenerationStore.revalidate < options.revalidate\n        ) {\n          // The store is already revalidating on a shorter time interval, leave it alone\n        } else {\n          staticGenerationStore.revalidate = options.revalidate\n        }\n      } else if (\n        options.revalidate === false &&\n        typeof staticGenerationStore.revalidate === 'undefined'\n      ) {\n        // The store has not defined revalidate type so we can use the false option\n        staticGenerationStore.revalidate = options.revalidate\n      }\n\n      // We need to accumulate the tags for this invocation within the store\n      if (!staticGenerationStore.tags) {\n        staticGenerationStore.tags = tags.slice()\n      } else {\n        for (const tag of tags) {\n          // @TODO refactor tags to be a set to avoid this O(n) lookup\n          if (!staticGenerationStore.tags.includes(tag)) {\n            staticGenerationStore.tags.push(tag)\n          }\n        }\n      }\n      // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n      // of this function is potentially a little confusing\n      const implicitTags = addImplicitTags(staticGenerationStore, requestStore)\n\n      if (\n        // when we are nested inside of other unstable_cache's\n        // we should bypass cache similar to fetches\n        staticGenerationStore.fetchCache !== 'force-no-store' &&\n        !staticGenerationStore.isOnDemandRevalidate &&\n        !incrementalCache.isOnDemandRevalidate &&\n        !staticGenerationStore.isDraftMode\n      ) {\n        // We attempt to get the current cache entry from the incremental cache.\n        const cacheEntry = await incrementalCache.get(cacheKey, {\n          kindHint: 'fetch',\n          revalidate: options.revalidate,\n          tags,\n          softTags: implicitTags,\n          fetchIdx,\n          fetchUrl,\n        })\n\n        if (cacheEntry && cacheEntry.value) {\n          // The entry exists and has a value\n          if (cacheEntry.value.kind !== 'FETCH') {\n            // The entry is invalid and we need a special warning\n            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n            // so bugs can be reported\n            // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n            console.error(\n              `Invariant invalid cacheEntry returned for ${invocationKey}`\n            )\n            // will fall through to generating a new cache entry below\n          } else {\n            // We have a valid cache entry so we will be returning it. We also check to see if we need\n            // to background revalidate it by checking if it is stale.\n            const cachedResponse =\n              cacheEntry.value.data.body !== undefined\n                ? JSON.parse(cacheEntry.value.data.body)\n                : undefined\n            if (cacheEntry.isStale) {\n              // In App Router we return the stale result and revalidate in the background\n              if (!staticGenerationStore.pendingRevalidates) {\n                staticGenerationStore.pendingRevalidates = {}\n              }\n              // We run the cache function asynchronously and save the result when it completes\n              staticGenerationStore.pendingRevalidates[invocationKey] =\n                staticGenerationAsyncStorage\n                  .run(\n                    {\n                      ...staticGenerationStore,\n                      // force any nested fetches to bypass cache so they revalidate\n                      // when the unstable_cache call is revalidated\n                      fetchCache: 'force-no-store',\n                      isUnstableCacheCallback: true,\n                    },\n                    cb,\n                    ...args\n                  )\n                  .then((result) => {\n                    return cacheNewResult(\n                      result,\n                      incrementalCache,\n                      cacheKey,\n                      tags,\n                      options.revalidate,\n                      fetchIdx,\n                      fetchUrl\n                    )\n                  })\n                  // @TODO This error handling seems wrong. We swallow the error?\n                  .catch((err) =>\n                    console.error(\n                      `revalidating cache with key: ${invocationKey}`,\n                      err\n                    )\n                  )\n            }\n            // We had a valid cache entry so we return it here\n            return cachedResponse\n          }\n        }\n      }\n\n      // If we got this far then we had an invalid cache entry and need to generate a new one\n      const result = await staticGenerationAsyncStorage.run(\n        {\n          ...staticGenerationStore,\n          // force any nested fetches to bypass cache so they revalidate\n          // when the unstable_cache call is revalidated\n          fetchCache: 'force-no-store',\n          isUnstableCacheCallback: true,\n        },\n        cb,\n        ...args\n      )\n\n      if (!staticGenerationStore.isDraftMode) {\n        cacheNewResult(\n          result,\n          incrementalCache,\n          cacheKey,\n          tags,\n          options.revalidate,\n          fetchIdx,\n          fetchUrl\n        )\n      }\n\n      return result\n    } else {\n      noStoreFetchIdx += 1\n      // We are in Pages Router or were called outside of a render. We don't have a store\n      // so we just call the callback directly when it needs to run.\n      // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n      // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n      if (!incrementalCache.isOnDemandRevalidate) {\n        // We aren't doing an on demand revalidation so we check use the cache if valid\n\n        // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n        // of this function is potentially a little confusing\n        const implicitTags =\n          staticGenerationStore &&\n          addImplicitTags(staticGenerationStore, requestStore)\n\n        const cacheEntry = await incrementalCache.get(cacheKey, {\n          kindHint: 'fetch',\n          revalidate: options.revalidate,\n          tags,\n          fetchIdx,\n          fetchUrl,\n          softTags: implicitTags,\n        })\n\n        if (cacheEntry && cacheEntry.value) {\n          // The entry exists and has a value\n          if (cacheEntry.value.kind !== 'FETCH') {\n            // The entry is invalid and we need a special warning\n            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n            // so bugs can be reported\n            console.error(\n              `Invariant invalid cacheEntry returned for ${invocationKey}`\n            )\n            // will fall through to generating a new cache entry below\n          } else if (!cacheEntry.isStale) {\n            // We have a valid cache entry and it is fresh so we return it\n            return cacheEntry.value.data.body !== undefined\n              ? JSON.parse(cacheEntry.value.data.body)\n              : undefined\n          }\n        }\n      }\n\n      // If we got this far then we had an invalid cache entry and need to generate a new one\n      // @TODO this storage wrapper is included here because it existed prior to the latest refactor\n      // however it is incorrect logic because it causes any internal cache calls to follow the App Router\n      // path rather than Pages router path. This may mean there is existing buggy behavior however no specific\n      // issues are known at this time. The whole static generation storage pathways should be reworked\n      // to allow tracking which \"mode\" we are in without the presence of a store or not. For now I have\n      // maintained the existing behavior to limit the impact of the current refactor\n      const result = await staticGenerationAsyncStorage.run(\n        // We are making a fake store that is useful for scoping fetchCache: 'force-no-store' and isUnstableCacheCallback: true\n        // The fact that we need to construct this kind of fake store indicates the code is not factored correctly\n        // @TODO refactor to not require this fake store object\n        {\n          // force any nested fetches to bypass cache so they revalidate\n          // when the unstable_cache call is revalidated\n          fetchCache: 'force-no-store',\n          isUnstableCacheCallback: true,\n          route: '/',\n          page: '/',\n          isStaticGeneration: false,\n          prerenderState: null,\n        },\n        cb,\n        ...args\n      )\n      cacheNewResult(\n        result,\n        incrementalCache,\n        cacheKey,\n        tags,\n        options.revalidate,\n        fetchIdx,\n        fetchUrl\n      )\n      return result\n    }\n  }\n  // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n  return cachedCb as unknown as T\n}\n"],"names":["CACHE_ONE_YEAR","addImplicitTags","validateRevalidate","validateTags","staticGenerationAsyncStorage","requestAsyncStorage","noStoreFetchIdx","cacheNewResult","result","incrementalCache","cacheKey","tags","revalidate","fetchIdx","fetchUrl","set","kind","data","headers","body","JSON","stringify","status","url","fetchCache","unstable_cache","cb","keyParts","options","Error","toString","name","fixedKey","Array","isArray","join","cachedCb","args","staticGenerationStore","getStore","requestStore","maybeIncrementalCache","globalThis","__incrementalCache","pathname","route","searchParams","URLSearchParams","search","sortedSearchKeys","keys","sort","a","b","localeCompare","sortedSearch","map","key","get","invocationKey","generateCacheKey","length","nextFetchId","slice","tag","includes","push","implicitTags","isOnDemandRevalidate","isDraftMode","cacheEntry","kindHint","softTags","value","console","error","cachedResponse","undefined","parse","isStale","pendingRevalidates","run","isUnstableCacheCallback","then","catch","err","page","isStaticGeneration","prerenderState"],"mappings":"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"}