{"version":3,"sources":["../../../../src/shared/lib/router/action-queue.ts"],"sourcesContent":["import {\n  isThenable,\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n} from '../../../client/components/router-reducer/router-reducer-types'\nimport type { ReduxDevToolsInstance } from '../../../client/components/use-reducer-with-devtools'\nimport { reducer } from '../../../client/components/router-reducer/router-reducer'\nimport { startTransition } from 'react'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  devToolsInstance?: ReduxDevToolsInstance\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    } else {\n      // No more actions are pending, check if a refresh is needed\n      if (actionQueue.needsRefresh) {\n        actionQueue.needsRefresh = false\n        actionQueue.dispatch(\n          {\n            type: ACTION_REFRESH,\n            origin: window.location.origin,\n          },\n          setState\n        )\n      }\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      return\n    }\n\n    actionQueue.state = nextState\n\n    if (actionQueue.devToolsInstance) {\n      actionQueue.devToolsInstance.send(payload, nextState)\n    }\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n    if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {\n      actionQueue.needsRefresh = true\n    }\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n  }\n\n  return actionQueue\n}\n"],"names":["createMutableActionQueue","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","origin","window","location","prevState","state","payload","actionResult","handleResult","nextState","discarded","devToolsInstance","send","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","ACTION_SERVER_ACTION","initialState","result","reducer"],"mappings":"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"}